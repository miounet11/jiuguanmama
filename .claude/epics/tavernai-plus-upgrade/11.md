---
name: "角色发现体验重构"
status: pending
created: 2025-09-21T02:07:42Z
updated: 2025-09-21T02:36:29Z
github: https://github.com/miounet11/jiuguanbaba/issues/11
depends_on: []
parallel: true
conflicts_with: []
estimated_effort: L
estimated_hours: 48
epic: tavernai-plus-upgrade
tags: ["ui", "discovery", "cards", "masonry", "character-grid"]
---

# Task 001: 角色发现体验重构

## 概述

实现QuackAI式瀑布流布局和简化卡片设计，重构角色发现体验。通过引入现代化的瀑布流布局、极简卡片设计和智能筛选功能，将角色浏览体验从传统网格转向Pinterest风格的沉浸式发现模式。

## 目标

- 实现Pinterest/QuackAI风格的瀑布流布局
- 设计极简化的角色卡片组件
- 优化角色信息的展示层次
- 实现智能搜索和筛选功能
- 保证移动端的完美适配

## 技术要求

### 核心组件开发

#### 1. CharacterCardSimple.vue - 极简角色卡片
```vue
<!-- 设计原则：信息层次化，视觉焦点突出 -->
<template>
  <div class="character-card-simple" @click="handleCardClick">
    <!-- 角色头像区域 -->
    <div class="card-avatar">
      <img :src="character.avatar" :alt="character.name" />
      <div class="avatar-overlay">
        <el-button type="primary" size="small" circle>
          <ChatDotRound />
        </el-button>
      </div>
    </div>

    <!-- 核心信息区域 -->
    <div class="card-content">
      <h3 class="character-name">{{ character.name }}</h3>
      <p class="character-description">{{ truncatedDescription }}</p>

      <!-- 标签区域 -->
      <div class="character-tags">
        <el-tag
          v-for="tag in limitedTags"
          :key="tag"
          size="small"
          effect="plain"
        >
          {{ tag }}
        </el-tag>
      </div>

      <!-- 统计信息 -->
      <div class="character-stats">
        <span class="stat-item">
          <Star class="stat-icon" />
          {{ character.rating }}
        </span>
        <span class="stat-item">
          <ChatLineRound class="stat-icon" />
          {{ character.messageCount }}
        </span>
      </div>
    </div>
  </div>
</template>
```

#### 2. CharacterGridMasonry.vue - 瀑布流容器
```vue
<template>
  <div class="character-grid-masonry" ref="masonryContainer">
    <!-- 搜索和筛选栏 -->
    <div class="grid-controls">
      <SmartSearchBar
        v-model="searchQuery"
        @search="handleSearch"
        :suggestions="searchSuggestions"
      />
      <FilterPanel
        v-model="activeFilters"
        @filter-change="handleFilterChange"
        :available-filters="availableFilters"
      />
    </div>

    <!-- 瀑布流网格 -->
    <div
      class="masonry-grid"
      :style="masonryGridStyles"
    >
      <CharacterCardSimple
        v-for="character in filteredCharacters"
        :key="character.id"
        :character="character"
        @click="handleCharacterSelect"
        :style="getCardStyles(character.id)"
      />
    </div>

    <!-- 加载更多 -->
    <div class="load-more" v-if="hasMore">
      <el-button
        @click="loadMore"
        :loading="loading"
        type="primary"
      >
        加载更多角色
      </el-button>
    </div>
  </div>
</template>
```

### 核心技术实现

#### 1. 瀑布流布局算法
```typescript
// composables/useMasonryLayout.ts
export function useMasonryLayout(containerRef: Ref<HTMLElement>) {
  const columnCount = ref(3)
  const columnHeights = ref<number[]>([])
  const cardPositions = ref<Map<string, { x: number; y: number }>>()

  const calculateLayout = (items: CharacterCard[]) => {
    const container = containerRef.value
    if (!container) return

    const containerWidth = container.offsetWidth
    const columnWidth = Math.floor(containerWidth / columnCount.value)
    const gap = 16

    // 重置列高度
    columnHeights.value = new Array(columnCount.value).fill(0)
    cardPositions.value = new Map()

    items.forEach((item, index) => {
      // 找到最短的列
      const shortestColumnIndex = columnHeights.value.indexOf(
        Math.min(...columnHeights.value)
      )

      const x = shortestColumnIndex * (columnWidth + gap)
      const y = columnHeights.value[shortestColumnIndex]

      cardPositions.value.set(item.id, { x, y })

      // 更新列高度 (需要异步获取实际卡片高度)
      nextTick(() => {
        const cardElement = container.querySelector(`[data-card-id="${item.id}"]`)
        if (cardElement) {
          columnHeights.value[shortestColumnIndex] += cardElement.offsetHeight + gap
        }
      })
    })
  }

  return {
    columnCount,
    cardPositions,
    calculateLayout
  }
}
```

#### 2. 智能搜索功能
```typescript
// composables/useCharacterSearch.ts
export function useCharacterSearch() {
  const searchQuery = ref('')
  const searchHistory = ref<string[]>([])
  const searchSuggestions = computed(() => {
    // 基于用户输入生成智能建议
    return generateSuggestions(searchQuery.value)
  })

  const performSearch = debounce(async (query: string) => {
    if (!query.trim()) return

    try {
      const results = await characterService.search({
        query,
        filters: activeFilters.value,
        limit: 20
      })

      // 更新搜索历史
      updateSearchHistory(query)

      return results
    } catch (error) {
      console.error('搜索失败:', error)
      throw error
    }
  }, 300)

  return {
    searchQuery,
    searchSuggestions,
    performSearch
  }
}
```

#### 3. 性能优化策略
```typescript
// utils/performanceOptimization.ts
export class MasonryPerformanceOptimizer {
  private intersectionObserver: IntersectionObserver
  private visibleCards = new Set<string>()

  constructor(private onCardVisible: (cardId: string) => void) {
    this.intersectionObserver = new IntersectionObserver(
      this.handleIntersection.bind(this),
      {
        rootMargin: '100px', // 提前100px开始加载
        threshold: 0.1
      }
    )
  }

  observeCard(cardElement: HTMLElement, cardId: string) {
    cardElement.dataset.cardId = cardId
    this.intersectionObserver.observe(cardElement)
  }

  private handleIntersection(entries: IntersectionObserverEntry[]) {
    entries.forEach(entry => {
      const cardId = entry.target.getAttribute('data-card-id')
      if (!cardId) return

      if (entry.isIntersecting) {
        if (!this.visibleCards.has(cardId)) {
          this.visibleCards.add(cardId)
          this.onCardVisible(cardId)
        }
      } else {
        this.visibleCards.delete(cardId)
      }
    })
  }
}
```

## 验收标准

### 功能验收标准
- [ ] **瀑布流布局正常工作**：支持3-5列自适应布局，卡片高度自动调整
- [ ] **角色卡片信息完整**：显示头像、名称、描述、标签、评分、聊天数量
- [ ] **搜索功能精确**：支持按名称、标签、描述搜索，响应时间<300ms
- [ ] **筛选功能丰富**：支持按类型、评分、创建时间、标签等多维度筛选
- [ ] **一键开始对话**：点击卡片或聊天按钮直接进入对话，无中间页面

### 性能验收标准
- [ ] **首屏渲染快速**：首屏20个角色卡片渲染时间<1.5秒
- [ ] **滚动加载流畅**：无限滚动加载，每页20个角色，加载时间<500ms
- [ ] **内存使用合理**：长时间浏览后内存占用不超过100MB
- [ ] **移动端适配完美**：在375px宽度下单列布局，操作流畅
- [ ] **图片加载优化**：支持懒加载和WebP格式，加载失败有fallback

### 用户体验验收标准
- [ ] **视觉层次清晰**：重要信息突出，次要信息弱化，符合视觉扫描习惯
- [ ] **交互反馈及时**：hover效果、点击反馈、加载状态等微交互完整
- [ ] **操作路径最短**：从进入页面到开始对话不超过2次点击
- [ ] **信息密度适中**：卡片内容丰富但不拥挤，易于快速浏览
- [ ] **错误处理友好**：网络错误、加载失败等情况有清晰的用户提示

## 实施细节

### 文件结构
```
apps/web/src/
├── components/character/
│   ├── CharacterCardSimple.vue          # 极简角色卡片
│   ├── CharacterGridMasonry.vue         # 瀑布流容器
│   ├── SmartSearchBar.vue               # 智能搜索栏
│   └── FilterPanel.vue                  # 筛选面板
├── composables/
│   ├── useMasonryLayout.ts              # 瀑布流布局逻辑
│   ├── useCharacterSearch.ts            # 搜索功能
│   └── useInfiniteScroll.ts             # 无限滚动
├── styles/
│   ├── components/character-cards.scss  # 卡片样式
│   └── layouts/masonry.scss             # 瀑布流布局样式
└── utils/
    └── performanceOptimization.ts       # 性能优化工具
```

### 样式系统
```scss
// styles/components/character-cards.scss
.character-card-simple {
  background: var(--el-bg-color);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  cursor: pointer;

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);

    .avatar-overlay {
      opacity: 1;
    }
  }

  .card-avatar {
    position: relative;
    aspect-ratio: 16/9;
    overflow: hidden;

    img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .avatar-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
  }

  .card-content {
    padding: 16px;

    .character-name {
      font-size: 16px;
      font-weight: 600;
      margin: 0 0 8px 0;
      color: var(--el-text-color-primary);
    }

    .character-description {
      font-size: 14px;
      color: var(--el-text-color-regular);
      line-height: 1.4;
      margin: 0 0 12px 0;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .character-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 12px;
    }

    .character-stats {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--el-text-color-secondary);

      .stat-item {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .stat-icon {
        width: 14px;
        height: 14px;
      }
    }
  }
}
```

### API集成
```typescript
// services/characterDiscoveryService.ts
export class CharacterDiscoveryService {
  async getCharacters(params: {
    page?: number
    limit?: number
    search?: string
    filters?: CharacterFilters
    sortBy?: 'popular' | 'recent' | 'rating'
  }): Promise<CharacterDiscoveryResponse> {
    const response = await api.get('/characters/discover', { params })
    return response.data
  }

  async getSearchSuggestions(query: string): Promise<string[]> {
    const response = await api.get('/characters/search/suggestions', {
      params: { q: query }
    })
    return response.data.suggestions
  }
}
```

## Definition of Done

### 代码质量检查清单
- [ ] **TypeScript类型安全**：所有组件和函数都有完整类型定义，无any类型
- [ ] **单元测试覆盖**：核心组件和composables测试覆盖率>80%
- [ ] **E2E测试通过**：角色发现完整流程的端到端测试通过
- [ ] **代码审查通过**：至少一名团队成员完成代码审查
- [ ] **性能测试达标**：Lighthouse性能评分>90，Core Web Vitals达标

### 集成测试检查清单
- [ ] **API集成正常**：所有角色数据API调用正常，错误处理完整
- [ ] **路由集成无误**：从角色发现页面跳转到对话页面路径正确
- [ ] **状态管理一致**：搜索状态、筛选状态在页面刷新后保持一致
- [ ] **主题切换兼容**：在亮色/暗色主题下样式都正常显示
- [ ] **响应式布局完美**：在所有主流设备和浏览器下显示正常

### 用户验收检查清单
- [ ] **新手用户友好**：首次访问用户能在30秒内理解如何浏览和选择角色
- [ ] **专家用户高效**：经验用户能快速找到特定类型角色，筛选功能强大
- [ ] **移动端体验优秀**：触控操作流畅，所有功能在移动端都可正常使用
- [ ] **加载体验良好**：网络慢时有合适的加载状态，不会出现白屏
- [ ] **错误恢复能力**：网络错误后能自动重试，用户可手动刷新恢复

---

*本任务是TavernAI Plus体验重构的核心基础，将直接影响用户的第一印象和角色选择效率。瀑布流布局和极简卡片设计将显著提升角色发现的愉悦度和效率。*