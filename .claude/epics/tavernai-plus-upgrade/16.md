---
name: "渐进式功能披露"
status: pending
created: 2025-09-21T02:07:42Z
updated: 2025-09-22T02:30:03Z
github: https://github.com/miounet11/jiuguanbaba/issues/16
depends_on: [11, 12, 13]
parallel: false
conflicts_with: []
estimated_effort: M
estimated_hours: 28
epic: tavernai-plus-upgrade
tags: ["progressive-disclosure", "user-modes", "ui-simplification", "expert-features"]
---

# Task 006: 渐进式功能披露

## 概述

实现简洁/专家模式切换机制，通过渐进式披露原则满足不同用户群体的需求。新手用户默认看到简化的界面专注于核心功能，专家用户可以切换到完整功能模式。建立智能的功能展示策略，根据用户行为和熟练程度动态调整界面复杂度。

## 目标

- 建立双模式UI系统（简洁模式 + 专家模式）
- 实现基于用户行为的智能模式推荐
- 开发功能渐进式展示机制
- 优化不同用户群体的学习曲线
- 保持所有功能的完整可访问性

## 技术要求

### 核心状态管理系统

#### 1. UserModeStore.ts - 用户模式状态管理
```typescript
// stores/userModeStore.ts
export interface UserMode {
  current: 'simplified' | 'expert'
  experience: UserExperience
  preferences: UserPreferences
  featureUnlocks: FeatureUnlock[]
  transitionHistory: ModeTransition[]
}

export interface UserExperience {
  totalSessions: number
  messagesCount: number
  charactersUsed: number
  featuresUsed: string[]
  expertFeaturesUsed: string[]
  lastActiveDate: Date
  skillLevel: 'beginner' | 'intermediate' | 'advanced' | 'expert'
}

export interface FeatureUnlock {
  featureId: string
  unlockedAt: Date
  trigger: 'usage' | 'time' | 'manual' | 'achievement'
  condition: string
}

export const useUserModeStore = defineStore('userMode', () => {
  const currentMode = ref<'simplified' | 'expert'>('simplified')
  const userExperience = ref<UserExperience>({
    totalSessions: 0,
    messagesCount: 0,
    charactersUsed: 0,
    featuresUsed: [],
    expertFeaturesUsed: [],
    lastActiveDate: new Date(),
    skillLevel: 'beginner'
  })

  const availableFeatures = computed(() => {
    return getAvailableFeaturesForMode(currentMode.value, userExperience.value)
  })

  const shouldSuggestModeUpgrade = computed(() => {
    return analyzeUpgradeOpportunity(userExperience.value, currentMode.value)
  })

  /**
   * 智能模式推荐算法
   * 基于用户行为分析是否应该推荐升级到专家模式
   */
  const analyzeUpgradeOpportunity = (
    experience: UserExperience,
    currentMode: string
  ): boolean => {
    if (currentMode === 'expert') return false

    const upgradeSignals = [
      experience.totalSessions >= 10,
      experience.messagesCount >= 100,
      experience.charactersUsed >= 5,
      experience.featuresUsed.length >= 8,
      experience.expertFeaturesUsed.length >= 2
    ]

    const signalCount = upgradeSignals.filter(Boolean).length
    return signalCount >= 3 // 至少满足3个条件
  }

  /**
   * 切换用户模式
   */
  const switchMode = async (newMode: 'simplified' | 'expert', reason?: string) => {
    const oldMode = currentMode.value
    currentMode.value = newMode

    // 记录切换历史
    await recordModeTransition({
      from: oldMode,
      to: newMode,
      timestamp: new Date(),
      reason: reason || 'manual',
      userInitiated: !reason
    })

    // 保存到本地存储和服务器
    await saveModePreference(newMode)

    // 触发界面重新渲染
    await nextTick()

    // 显示模式切换引导
    if (newMode === 'expert' && oldMode === 'simplified') {
      showExpertModeGuide()
    }
  }

  /**
   * 记录功能使用情况
   */
  const recordFeatureUsage = (featureId: string, isExpertFeature = false) => {
    if (!userExperience.value.featuresUsed.includes(featureId)) {
      userExperience.value.featuresUsed.push(featureId)
    }

    if (isExpertFeature && !userExperience.value.expertFeaturesUsed.includes(featureId)) {
      userExperience.value.expertFeaturesUsed.push(featureId)
    }

    // 更新技能水平
    updateSkillLevel()

    // 检查是否有新功能解锁
    checkFeatureUnlocks(featureId)
  }

  /**
   * 动态更新用户技能水平
   */
  const updateSkillLevel = () => {
    const exp = userExperience.value
    const totalUsage = exp.totalSessions + exp.messagesCount / 10 + exp.charactersUsed * 2

    if (totalUsage >= 200 && exp.expertFeaturesUsed.length >= 5) {
      exp.skillLevel = 'expert'
    } else if (totalUsage >= 100 && exp.featuresUsed.length >= 10) {
      exp.skillLevel = 'advanced'
    } else if (totalUsage >= 50 && exp.featuresUsed.length >= 5) {
      exp.skillLevel = 'intermediate'
    } else {
      exp.skillLevel = 'beginner'
    }
  }

  /**
   * 检查功能解锁条件
   */
  const checkFeatureUnlocks = (triggerFeatureId: string) => {
    const unlockRules = getFeatureUnlockRules()

    for (const rule of unlockRules) {
      if (isUnlockConditionMet(rule, userExperience.value, triggerFeatureId)) {
        unlockFeature(rule.featureId, rule.trigger, rule.condition)
      }
    }
  }

  return {
    currentMode: readonly(currentMode),
    userExperience: readonly(userExperience),
    availableFeatures,
    shouldSuggestModeUpgrade,
    switchMode,
    recordFeatureUsage,
    updateSkillLevel
  }
})
```

#### 2. ProgressiveDisclosure.vue - 渐进式披露控制组件
```vue
<template>
  <div class="progressive-disclosure-wrapper">
    <!-- 模式切换器 -->
    <div class="mode-switcher" v-if="showModeSwitcher">
      <el-switch
        v-model="isExpertMode"
        @change="handleModeSwitch"
        active-text="专家模式"
        inactive-text="简洁模式"
        :active-icon="Setting"
        :inactive-icon="User"
        size="small"
      />

      <!-- 模式说明 -->
      <el-tooltip :content="modeDescription" placement="bottom">
        <el-icon class="mode-info"><QuestionFilled /></el-icon>
      </el-tooltip>
    </div>

    <!-- 功能渐进披露容器 -->
    <div class="feature-container" :class="containerClass">
      <slot
        :visible-features="visibleFeatures"
        :feature-state="featureState"
        :unlock-feature="unlockFeature"
      />
    </div>

    <!-- 升级建议提示 -->
    <el-alert
      v-if="showUpgradeSuggestion"
      title="发现更多功能"
      type="info"
      :description="upgradeSuggestionText"
      show-icon
      :closable="true"
      @close="dismissUpgradeSuggestion"
    >
      <template #default>
        <div class="upgrade-suggestion">
          <p>{{ upgradeSuggestionText }}</p>
          <div class="suggestion-actions">
            <el-button size="small" type="primary" @click="upgradeToExpertMode">
              切换到专家模式
            </el-button>
            <el-button size="small" @click="dismissUpgradeSuggestion">
              稍后提醒
            </el-button>
          </div>
        </div>
      </template>
    </el-alert>

    <!-- 新功能解锁通知 -->
    <transition name="feature-unlock">
      <div v-if="showUnlockNotification" class="feature-unlock-notification">
        <el-icon class="unlock-icon"><Star /></el-icon>
        <div class="unlock-content">
          <h4>🎉 解锁新功能</h4>
          <p>{{ latestUnlockedFeature?.name }}</p>
          <small>{{ latestUnlockedFeature?.description }}</small>
        </div>
        <el-button size="small" @click="dismissUnlockNotification">知道了</el-button>
      </div>
    </transition>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, watch } from 'vue'
import { useUserModeStore } from '@/stores/userModeStore'
import { getFeatureManifest } from '@/utils/featureManifest'

interface Props {
  featureScope?: string
  allowModeSwitch?: boolean
  showUpgradeSuggestions?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  featureScope: 'global',
  allowModeSwitch: true,
  showUpgradeSuggestions: true
})

const userModeStore = useUserModeStore()
const showUnlockNotification = ref(false)
const latestUnlockedFeature = ref<any>(null)

const isExpertMode = computed({
  get: () => userModeStore.currentMode === 'expert',
  set: (value) => {
    const newMode = value ? 'expert' : 'simplified'
    userModeStore.switchMode(newMode, 'user-toggle')
  }
})

const showModeSwitcher = computed(() => {
  return props.allowModeSwitch && (
    isExpertMode.value ||
    userModeStore.shouldSuggestModeUpgrade
  )
})

const modeDescription = computed(() => {
  return isExpertMode.value
    ? '专家模式：显示所有高级功能和详细控制选项'
    : '简洁模式：只显示核心功能，界面更加简洁'
})

const containerClass = computed(() => ({
  'simplified-mode': !isExpertMode.value,
  'expert-mode': isExpertMode.value,
  [`scope-${props.featureScope}`]: true
}))

const visibleFeatures = computed(() => {
  const manifest = getFeatureManifest(props.featureScope)
  const currentMode = userModeStore.currentMode

  return manifest.filter(feature => {
    // 简洁模式下只显示核心功能
    if (currentMode === 'simplified') {
      return feature.coreFeature || feature.unlockedInSimplified
    }
    // 专家模式显示所有功能
    return true
  })
})

const featureState = computed(() => {
  const state = new Map()

  visibleFeatures.value.forEach(feature => {
    state.set(feature.id, {
      visible: true,
      enabled: isFeatureEnabled(feature),
      highlighted: isFeatureNewlyUnlocked(feature),
      description: getFeatureDescription(feature, isExpertMode.value)
    })
  })

  return state
})

const showUpgradeSuggestion = computed(() => {
  return props.showUpgradeSuggestions &&
         !isExpertMode.value &&
         userModeStore.shouldSuggestModeUpgrade
})

const upgradeSuggestionText = computed(() => {
  const expertFeatures = userModeStore.userExperience.expertFeaturesUsed.length
  const totalSessions = userModeStore.userExperience.totalSessions

  return `您已经使用了 ${expertFeatures} 个高级功能，进行了 ${totalSessions} 次会话。` +
         `切换到专家模式可以获得完整的控制能力和更多定制选项。`
})

/**
 * 处理模式切换
 */
const handleModeSwitch = (isExpert: boolean) => {
  const reason = isExpert ? 'upgrade-suggestion' : 'simplify-preference'
  userModeStore.recordFeatureUsage('mode-switch', true)
}

/**
 * 升级到专家模式
 */
const upgradeToExpertMode = () => {
  isExpertMode.value = true
  userModeStore.recordFeatureUsage('upgrade-from-suggestion', true)
}

/**
 * 解锁特定功能
 */
const unlockFeature = (featureId: string) => {
  const feature = getFeatureManifest(props.featureScope)
    .find(f => f.id === featureId)

  if (feature) {
    latestUnlockedFeature.value = feature
    showUnlockNotification.value = true

    userModeStore.recordFeatureUsage(featureId, feature.isExpertFeature)
  }
}

/**
 * 检查功能是否启用
 */
const isFeatureEnabled = (feature: any): boolean => {
  const userExp = userModeStore.userExperience

  // 检查解锁条件
  if (feature.unlockCondition) {
    return evaluateUnlockCondition(feature.unlockCondition, userExp)
  }

  return true
}

/**
 * 检查功能是否为新解锁
 */
const isFeatureNewlyUnlocked = (feature: any): boolean => {
  // 检查最近3天内是否解锁了此功能
  const recentUnlocks = userModeStore.userExperience.featuresUsed
    .filter(f => Date.now() - new Date().getTime() < 3 * 24 * 60 * 60 * 1000)

  return recentUnlocks.includes(feature.id)
}

/**
 * 获取功能描述
 */
const getFeatureDescription = (feature: any, isExpertMode: boolean): string => {
  return isExpertMode ? feature.expertDescription : feature.simpleDescription
}

/**
 * 评估解锁条件
 */
const evaluateUnlockCondition = (condition: string, userExp: UserExperience): boolean => {
  // 简单的条件评估器
  try {
    const context = {
      sessions: userExp.totalSessions,
      messages: userExp.messagesCount,
      characters: userExp.charactersUsed,
      features: userExp.featuresUsed.length,
      skillLevel: userExp.skillLevel
    }

    // 使用安全的条件评估
    return evaluateConditionSafely(condition, context)
  } catch (error) {
    console.error('条件评估失败:', error)
    return false
  }
}

const dismissUpgradeSuggestion = () => {
  // 暂时隐藏升级建议，24小时后再次显示
  localStorage.setItem('upgradeSuggestionDismissed', Date.now().toString())
}

const dismissUnlockNotification = () => {
  showUnlockNotification.value = false
  latestUnlockedFeature.value = null
}

// 监听功能解锁事件
watch(() => userModeStore.userExperience.featuresUsed, (newFeatures, oldFeatures) => {
  if (newFeatures.length > oldFeatures.length) {
    const newestFeature = newFeatures[newFeatures.length - 1]
    const feature = getFeatureManifest().find(f => f.id === newestFeature)
    if (feature && feature.showUnlockNotification) {
      unlockFeature(newestFeature)
    }
  }
}, { deep: true })
</script>

<style scoped lang="scss">
.progressive-disclosure-wrapper {
  position: relative;

  .mode-switcher {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 16px;
    padding: 8px 12px;
    background: var(--el-fill-color-lighter);
    border-radius: 6px;
    font-size: 13px;

    .mode-info {
      color: var(--el-text-color-secondary);
      cursor: help;
    }
  }

  .feature-container {
    transition: all 0.3s ease;

    &.simplified-mode {
      // 简化模式样式
      .expert-only {
        display: none !important;
      }

      .feature-item {
        margin-bottom: 8px;
      }
    }

    &.expert-mode {
      // 专家模式样式
      .feature-item {
        margin-bottom: 12px;

        &.expert-feature {
          border-left: 3px solid var(--el-color-primary);
          padding-left: 12px;
        }
      }
    }
  }

  .upgrade-suggestion {
    .suggestion-actions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
    }
  }

  .feature-unlock-notification {
    position: fixed;
    top: 80px;
    right: 20px;
    background: var(--el-bg-color);
    border: 1px solid var(--el-color-primary);
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: center;
    gap: 12px;
    max-width: 320px;
    z-index: 2000;

    .unlock-icon {
      color: var(--el-color-warning);
      font-size: 24px;
    }

    .unlock-content {
      flex: 1;

      h4 {
        margin: 0 0 4px 0;
        color: var(--el-text-color-primary);
        font-size: 14px;
      }

      p {
        margin: 0 0 4px 0;
        font-weight: 600;
        color: var(--el-color-primary);
      }

      small {
        color: var(--el-text-color-secondary);
        line-height: 1.3;
      }
    }
  }
}

.feature-unlock-enter-active,
.feature-unlock-leave-active {
  transition: all 0.3s ease;
}

.feature-unlock-enter-from {
  transform: translateX(100%);
  opacity: 0;
}

.feature-unlock-leave-to {
  transform: translateX(100%);
  opacity: 0;
}
</style>
```

#### 3. 功能清单管理 - featureManifest.ts
```typescript
// utils/featureManifest.ts
export interface FeatureDefinition {
  id: string
  name: string
  simpleDescription: string
  expertDescription: string
  category: 'core' | 'advanced' | 'expert'
  coreFeature: boolean
  isExpertFeature: boolean
  scope: string[]
  unlockCondition?: string
  dependencies?: string[]
  showUnlockNotification: boolean
  unlockedInSimplified?: boolean
}

export const FEATURE_MANIFEST: FeatureDefinition[] = [
  // 角色浏览功能
  {
    id: 'character-basic-browse',
    name: '角色浏览',
    simpleDescription: '浏览和选择AI角色',
    expertDescription: '完整的角色库浏览，包含详细筛选和排序',
    category: 'core',
    coreFeature: true,
    isExpertFeature: false,
    scope: ['character-discovery'],
    showUnlockNotification: false,
    unlockedInSimplified: true
  },
  {
    id: 'character-advanced-search',
    name: '高级搜索',
    simpleDescription: '搜索特定角色',
    expertDescription: '多维度搜索：标签、描述、评分、创建时间等',
    category: 'advanced',
    coreFeature: false,
    isExpertFeature: true,
    scope: ['character-discovery'],
    unlockCondition: 'characters >= 10 || sessions >= 5',
    showUnlockNotification: true
  },

  // 对话功能
  {
    id: 'chat-basic',
    name: '基础对话',
    simpleDescription: '与AI角色对话',
    expertDescription: '基础文本对话功能',
    category: 'core',
    coreFeature: true,
    isExpertFeature: false,
    scope: ['chat'],
    showUnlockNotification: false,
    unlockedInSimplified: true
  },
  {
    id: 'chat-message-editing',
    name: '消息编辑',
    simpleDescription: '编辑和重发消息',
    expertDescription: '编辑历史消息，重新生成响应，分支对话',
    category: 'advanced',
    coreFeature: false,
    isExpertFeature: true,
    scope: ['chat'],
    unlockCondition: 'messages >= 50',
    showUnlockNotification: true
  },
  {
    id: 'chat-ai-model-selection',
    name: 'AI模型选择',
    simpleDescription: '选择不同的AI模型',
    expertDescription: '切换Grok-3、Claude、GPT等不同模型，调节参数',
    category: 'expert',
    coreFeature: false,
    isExpertFeature: true,
    scope: ['chat'],
    unlockCondition: 'sessions >= 15 && features >= 8',
    showUnlockNotification: true
  },

  // 角色创建功能
  {
    id: 'character-creation-basic',
    name: '角色创建',
    simpleDescription: '创建自定义角色',
    expertDescription: '使用模板创建角色',
    category: 'advanced',
    coreFeature: false,
    isExpertFeature: false,
    scope: ['character-creation'],
    unlockCondition: 'sessions >= 3',
    showUnlockNotification: true,
    unlockedInSimplified: true
  },
  {
    id: 'character-ai-generation',
    name: 'AI角色生成',
    simpleDescription: '让AI帮你创建角色',
    expertDescription: 'AI驱动的角色生成，包含头像、背景、性格设定',
    category: 'advanced',
    coreFeature: false,
    isExpertFeature: true,
    scope: ['character-creation'],
    unlockCondition: 'characters >= 2 && messages >= 100',
    dependencies: ['character-creation-basic'],
    showUnlockNotification: true
  },

  // 世界观功能
  {
    id: 'worldinfo-basic',
    name: '世界观信息',
    simpleDescription: '查看角色背景信息',
    expertDescription: '基础世界观信息查看',
    category: 'advanced',
    coreFeature: false,
    isExpertFeature: false,
    scope: ['chat', 'worldinfo'],
    unlockCondition: 'messages >= 30',
    showUnlockNotification: true
  },
  {
    id: 'worldinfo-dynamic-injection',
    name: '动态世界观',
    simpleDescription: '智能背景信息提示',
    expertDescription: 'AI自动分析对话并提供相关世界观信息',
    category: 'expert',
    coreFeature: false,
    isExpertFeature: true,
    scope: ['chat', 'worldinfo'],
    unlockCondition: 'sessions >= 10 && skillLevel >= "intermediate"',
    dependencies: ['worldinfo-basic'],
    showUnlockNotification: true
  },

  // 高级功能
  {
    id: 'chat-export',
    name: '对话导出',
    simpleDescription: '保存对话记录',
    expertDescription: '导出对话为多种格式：TXT、JSON、PDF等',
    category: 'expert',
    coreFeature: false,
    isExpertFeature: true,
    scope: ['chat'],
    unlockCondition: 'messages >= 200',
    showUnlockNotification: true
  },
  {
    id: 'character-sharing',
    name: '角色分享',
    simpleDescription: '分享你的角色',
    expertDescription: '发布角色到社区，设置分享权限和标签',
    category: 'expert',
    coreFeature: false,
    isExpertFeature: true,
    scope: ['character-creation'],
    unlockCondition: 'characters >= 5 && sessions >= 20',
    showUnlockNotification: true
  }
]

/**
 * 获取指定范围的功能清单
 */
export function getFeatureManifest(scope = 'global'): FeatureDefinition[] {
  if (scope === 'global') {
    return FEATURE_MANIFEST
  }

  return FEATURE_MANIFEST.filter(feature =>
    feature.scope.includes(scope)
  )
}

/**
 * 安全的条件评估器
 */
export function evaluateConditionSafely(condition: string, context: any): boolean {
  try {
    // 简单的条件解析器，支持基本比较
    const operators = ['>=', '<=', '>', '<', '==', '!=']

    for (const op of operators) {
      if (condition.includes(op)) {
        const [left, right] = condition.split(op).map(s => s.trim())
        const leftValue = context[left] || 0
        const rightValue = parseInt(right) || 0

        switch (op) {
          case '>=': return leftValue >= rightValue
          case '<=': return leftValue <= rightValue
          case '>': return leftValue > rightValue
          case '<': return leftValue < rightValue
          case '==': return leftValue == rightValue
          case '!=': return leftValue != rightValue
        }
      }
    }

    // 检查布尔条件
    if (condition.includes('&&')) {
      const conditions = condition.split('&&').map(c => c.trim())
      return conditions.every(c => evaluateConditionSafely(c, context))
    }

    if (condition.includes('||')) {
      const conditions = condition.split('||').map(c => c.trim())
      return conditions.some(c => evaluateConditionSafely(c, context))
    }

    return false
  } catch (error) {
    console.error('条件评估错误:', error)
    return false
  }
}

/**
 * 获取功能解锁规则
 */
export function getFeatureUnlockRules() {
  return FEATURE_MANIFEST
    .filter(feature => feature.unlockCondition)
    .map(feature => ({
      featureId: feature.id,
      condition: feature.unlockCondition!,
      trigger: 'usage' as const,
      dependencies: feature.dependencies || []
    }))
}
```

## 验收标准

### 功能验收标准
- [ ] **模式切换完整性**：用户能在简洁和专家模式间无缝切换，界面响应及时
- [ ] **功能渐进披露**：新手用户只看到核心功能，随使用经验增长逐步解锁
- [ ] **智能推荐准确性**：系统能准确判断用户何时准备升级到专家模式
- [ ] **功能状态持久化**：用户偏好和解锁状态在刷新页面后保持不变
- [ ] **功能依赖关系正确**：高级功能的解锁遵循正确的依赖顺序

### 性能验收标准
- [ ] **模式切换响应速度**：模式切换完成时间<500ms，包含界面重新渲染
- [ ] **功能状态计算效率**：功能可见性计算时间<100ms，不阻塞界面
- [ ] **本地存储优化**：用户偏好数据大小<50KB，读写速度<50ms
- [ ] **内存使用控制**：功能状态管理内存占用<10MB
- [ ] **初始化速度**：页面首次加载时功能状态初始化<200ms

### 用户体验验收标准
- [ ] **学习曲线优化**：新手用户能在5分钟内掌握简洁模式的所有功能
- [ ] **升级引导清晰**：专家模式升级建议出现时机恰当，说明清楚
- [ ] **功能发现自然**：用户能通过自然使用逐步发现新功能
- [ ] **界面一致性**：两种模式下的界面风格和交互保持一致
- [ ] **退回友好性**：用户可以随时从专家模式退回到简洁模式

### 智能化验收标准
- [ ] **行为分析准确**：系统能准确分析用户技能水平和使用模式
- [ ] **推荐时机合适**：功能解锁和模式升级建议在恰当时机出现
- [ ] **个性化程度高**：不同用户看到的功能披露路径有所差异
- [ ] **适应性强**：系统能根据用户反馈调整推荐策略
- [ ] **解锁条件合理**：功能解锁条件既不过于简单也不过于困难

## 实施细节

### 文件结构
```
apps/web/src/
├── stores/
│   ├── userModeStore.ts                  # 用户模式状态管理
│   └── featureUnlockStore.ts             # 功能解锁状态管理
├── components/progressive/
│   ├── ProgressiveDisclosure.vue         # 渐进式披露控制组件
│   ├── ModeSwitch.vue                    # 模式切换器
│   ├── FeatureUnlockNotification.vue     # 功能解锁通知
│   └── UpgradeSuggestion.vue             # 升级建议组件
├── composables/
│   ├── useProgressiveDisclosure.ts       # 渐进式披露逻辑
│   ├── useFeatureUnlock.ts               # 功能解锁管理
│   └── useModeTransition.ts              # 模式切换动画
├── utils/
│   ├── featureManifest.ts                # 功能清单管理
│   ├── conditionEvaluator.ts             # 条件评估器
│   └── userBehaviorAnalyzer.ts           # 用户行为分析
└── styles/
    ├── progressive-disclosure.scss        # 渐进式披露样式
    └── mode-transitions.scss              # 模式切换动画
```

### 组件集成示例
```vue
<!-- 在角色发现页面中使用 -->
<template>
  <ProgressiveDisclosure
    feature-scope="character-discovery"
    :allow-mode-switch="true"
    :show-upgrade-suggestions="true"
  >
    <template #default="{ visibleFeatures, featureState, unlockFeature }">
      <!-- 基础角色浏览 -->
      <CharacterGridMasonry
        v-if="featureState.get('character-basic-browse')?.visible"
        :characters="characters"
        @select="handleCharacterSelect"
      />

      <!-- 高级搜索 -->
      <AdvancedSearchPanel
        v-if="featureState.get('character-advanced-search')?.visible"
        @search="handleAdvancedSearch"
        :highlighted="featureState.get('character-advanced-search')?.highlighted"
      />
    </template>
  </ProgressiveDisclosure>
</template>
```

### API设计
```typescript
// API端点设计
interface UserModeAPI {
  // 获取用户模式配置
  getUserMode(userId: string): Promise<UserMode>

  // 更新用户模式
  updateUserMode(userId: string, mode: UserMode): Promise<void>

  // 记录功能使用
  recordFeatureUsage(userId: string, featureId: string): Promise<void>

  // 获取功能解锁状态
  getFeatureUnlocks(userId: string): Promise<FeatureUnlock[]>

  // 分析升级建议
  analyzeUpgradeOpportunity(userId: string): Promise<UpgradeAnalysis>
}
```

### 数据库扩展
```sql
-- 用户模式表
CREATE TABLE user_modes (
  user_id VARCHAR(255) PRIMARY KEY,
  current_mode ENUM('simplified', 'expert') DEFAULT 'simplified',
  total_sessions INT DEFAULT 0,
  messages_count INT DEFAULT 0,
  characters_used INT DEFAULT 0,
  skill_level ENUM('beginner', 'intermediate', 'advanced', 'expert') DEFAULT 'beginner',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 功能使用记录表
CREATE TABLE feature_usage_logs (
  id VARCHAR(255) PRIMARY KEY,
  user_id VARCHAR(255),
  feature_id VARCHAR(100),
  is_expert_feature BOOLEAN DEFAULT FALSE,
  usage_count INT DEFAULT 1,
  first_used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_user_feature (user_id, feature_id),
  INDEX idx_usage_time (last_used_at),
  FOREIGN KEY (user_id) REFERENCES users(id),
  UNIQUE KEY uk_user_feature (user_id, feature_id)
);

-- 功能解锁记录表
CREATE TABLE feature_unlocks (
  id VARCHAR(255) PRIMARY KEY,
  user_id VARCHAR(255),
  feature_id VARCHAR(100),
  unlock_trigger ENUM('usage', 'time', 'manual', 'achievement'),
  unlock_condition TEXT,
  unlocked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_user_unlock (user_id, unlocked_at),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 模式切换历史表
CREATE TABLE mode_transitions (
  id VARCHAR(255) PRIMARY KEY,
  user_id VARCHAR(255),
  from_mode ENUM('simplified', 'expert'),
  to_mode ENUM('simplified', 'expert'),
  reason VARCHAR(100),
  user_initiated BOOLEAN DEFAULT TRUE,
  transitioned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_user_transitions (user_id, transitioned_at),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 集成测试方案
```typescript
// tests/integration/progressiveDisclosure.test.ts
describe('渐进式功能披露系统', () => {
  test('新用户应该只看到核心功能', async () => {
    const newUser = await createTestUser()
    const userModeStore = useUserModeStore()

    // 模拟新用户状态
    userModeStore.userExperience.totalSessions = 0
    userModeStore.userExperience.messagesCount = 0

    const manifest = getFeatureManifest('character-discovery')
    const visibleFeatures = manifest.filter(f =>
      f.coreFeature || f.unlockedInSimplified
    )

    expect(visibleFeatures).toHaveLength(1) // 只有基础浏览功能
    expect(visibleFeatures[0].id).toBe('character-basic-browse')
  })

  test('应该在满足条件时解锁高级功能', async () => {
    const userModeStore = useUserModeStore()

    // 模拟用户达到解锁条件
    userModeStore.userExperience.totalSessions = 10
    userModeStore.userExperience.charactersUsed = 15

    userModeStore.recordFeatureUsage('character-basic-browse')

    // 检查是否解锁了高级搜索
    const unlocked = isFeatureUnlocked('character-advanced-search', userModeStore.userExperience)
    expect(unlocked).toBe(true)
  })

  test('应该在适当时机建议升级到专家模式', async () => {
    const userModeStore = useUserModeStore()

    // 模拟专家用户行为
    userModeStore.userExperience.totalSessions = 20
    userModeStore.userExperience.messagesCount = 500
    userModeStore.userExperience.expertFeaturesUsed = ['chat-ai-model-selection', 'character-ai-generation']

    const shouldSuggest = userModeStore.shouldSuggestModeUpgrade
    expect(shouldSuggest).toBe(true)
  })

  test('模式切换应该保持状态一致性', async () => {
    const userModeStore = useUserModeStore()

    // 切换到专家模式
    await userModeStore.switchMode('expert', 'test')
    expect(userModeStore.currentMode).toBe('expert')

    // 检查功能可见性
    const manifest = getFeatureManifest('chat')
    const expertFeatures = manifest.filter(f => f.isExpertFeature)

    expertFeatures.forEach(feature => {
      const isVisible = isFeatureVisible(feature, 'expert', userModeStore.userExperience)
      expect(isVisible).toBe(true)
    })
  })
})
```

## Definition of Done

### 代码质量检查清单
- [ ] **TypeScript类型安全**：所有状态管理和组件类型定义完整，无any使用
- [ ] **单元测试完整**：核心逻辑和组件测试覆盖率>90%
- [ ] **集成测试通过**：功能解锁、模式切换、状态持久化的端到端测试
- [ ] **代码审查完成**：状态管理逻辑和算法通过技术审查
- [ ] **性能测试达标**：模式切换和功能计算性能满足要求

### 功能完整性检查清单
- [ ] **功能清单完整**：所有现有功能都已加入渐进式披露系统
- [ ] **解锁条件合理**：通过用户测试验证解锁条件的合理性
- [ ] **模式切换无缝**：两种模式间切换不丢失用户状态
- [ ] **持久化可靠**：用户偏好在各种场景下都能正确保存和恢复
- [ ] **回滚安全**：可以安全禁用渐进式披露，恢复到原有界面

### 用户体验检查清单
- [ ] **新手友好度高**：新用户在简洁模式下学习成本低
- [ ] **专家效率保障**：专家模式不影响高级用户的使用效率
- [ ] **升级引导自然**：模式升级建议时机恰当，不干扰正常使用
- [ ] **功能发现流畅**：用户能通过自然使用发现新功能
- [ ] **反馈机制完善**：用户对推荐和解锁有明确的反馈渠道

### 智能化质量检查清单
- [ ] **行为分析准确**：用户技能水平判断准确率>85%
- [ ] **推荐算法优化**：升级建议的接受率>60%
- [ ] **个性化效果明显**：不同用户群体的功能披露路径有明显差异
- [ ] **学习能力强**：系统能根据用户行为调整推荐策略
- [ ] **预测准确性高**：功能需求预测准确率>70%

### 集成兼容性检查清单
- [ ] **与Task001-003完美集成**：不影响角色发现、对话流程、聊天界面功能
- [ ] **向后兼容**：现有用户升级后功能使用习惯不受影响
- [ ] **数据迁移安全**：现有用户数据正确迁移到新的模式系统
- [ ] **API兼容性**：不破坏现有的前端组件接口
- [ ] **主题系统兼容**：在不同主题下都能正确显示

### 维护性检查清单
- [ ] **功能清单易维护**：新功能能轻松加入渐进式披露系统
- [ ] **条件配置灵活**：解锁条件可以通过配置文件调整
- [ ] **监控数据完整**：提供详细的用户行为和功能使用数据
- [ ] **A/B测试支持**：支持不同披露策略的对比测试
- [ ] **文档完善**：包含功能配置、条件设置、故障排查文档

---

*本任务是TavernAI Plus用户体验优化的关键组成部分，通过智能的渐进式功能披露，我们将为不同经验水平的用户提供最适合的界面复杂度，确保新手用户不被复杂功能困扰，同时保证专家用户获得完整的控制能力。*