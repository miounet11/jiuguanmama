---
name: "性能监控与测试"
status: pending
created: 2025-09-21T02:07:42Z
updated: 2025-09-21T02:36:29Z
github: https://github.com/miounet11/jiuguanbaba/issues/18
depends_on: [11, 12, 13, 14, 15, 16, 17]
parallel: false
conflicts_with: []
estimated_effort: L
estimated_hours: 40
epic: tavernai-plus-upgrade
tags: ["performance-monitoring", "e2e-testing", "quality-assurance", "ttfm-tracking"]
---

# Task 008: 性能监控与测试

## 概述

建立完整的TTFM（Time To First Message）监控体系、自动化测试框架和质量保证机制，确保TavernAI Plus的"创世纪"升级达到预期的性能指标和用户体验目标。实现实时性能监控、端到端测试覆盖和持续质量改进机制。

## 目标

- 建立TTFM<30秒的监控和优化体系
- 实现完整的端到端自动化测试覆盖
- 建立Core Web Vitals持续监控机制
- 实现性能回归自动检测和告警
- 建立用户体验质量度量和改进机制

## 技术要求

### 核心性能监控系统

#### 1. PerformanceMonitor.ts - 综合性能监控服务
```typescript
// services/performanceMonitor.ts
export class PerformanceMonitorService {
  private metricsCollector: MetricsCollector
  private alertingService: AlertingService
  private analyticsReporter: AnalyticsReporter
  private performanceObserver: PerformanceObserver

  constructor() {
    this.metricsCollector = new MetricsCollector()
    this.alertingService = new AlertingService()
    this.analyticsReporter = new AnalyticsReporter()
    this.initializePerformanceObserver()
  }

  /**
   * 初始化性能观察器
   */
  private initializePerformanceObserver() {
    if ('PerformanceObserver' in window) {
      // 监控Core Web Vitals
      this.observeCoreWebVitals()

      // 监控用户交互性能
      this.observeUserInteraction()

      // 监控资源加载性能
      this.observeResourcePerformance()

      // 监控长任务
      this.observeLongTasks()
    }
  }

  /**
   * 监控Core Web Vitals指标
   */
  private observeCoreWebVitals() {
    // First Contentful Paint (FCP)
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.name === 'first-contentful-paint') {
          this.recordMetric('FCP', entry.startTime, {
            target: 1500, // 目标1.5秒
            critical: 2500 // 严重阈值2.5秒
          })
        }
      }
    }).observe({ entryTypes: ['paint'] })

    // Largest Contentful Paint (LCP)
    new PerformanceObserver((list) => {
      const entries = list.getEntries()
      const lastEntry = entries[entries.length - 1]

      this.recordMetric('LCP', lastEntry.startTime, {
        target: 2500, // 目标2.5秒
        critical: 4000 // 严重阈值4秒
      })
    }).observe({ entryTypes: ['largest-contentful-paint'] })

    // Cumulative Layout Shift (CLS)
    let clsValue = 0
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value
        }
      }

      this.recordMetric('CLS', clsValue, {
        target: 0.1, // 目标0.1
        critical: 0.25 // 严重阈值0.25
      })
    }).observe({ entryTypes: ['layout-shift'] })

    // First Input Delay (FID)
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.recordMetric('FID', entry.processingStart - entry.startTime, {
          target: 100, // 目标100ms
          critical: 300 // 严重阈值300ms
        })
      }
    }).observe({ entryTypes: ['first-input'] })
  }

  /**
   * 监控TTFM关键指标
   */
  async startTTFMTracking(sessionId: string) {
    const startTime = performance.now()
    const trackingData = {
      sessionId,
      startTime,
      milestones: new Map<string, number>(),
      userActions: []
    }

    // 记录关键里程碑
    this.trackMilestone(trackingData, 'page_load', startTime)

    // 监听用户交互
    this.observeUserActions(trackingData)

    // 监听首次消息发送
    this.observeFirstMessage(trackingData)

    return trackingData
  }

  /**
   * 记录关键里程碑
   */
  private trackMilestone(trackingData: any, milestone: string, timestamp?: number) {
    const time = timestamp || performance.now()
    trackingData.milestones.set(milestone, time)

    // 实时分析是否可能超时
    if (milestone === 'character_selected') {
      const elapsedTime = time - trackingData.startTime
      if (elapsedTime > 20000) { // 20秒警告
        this.alertingService.sendAlert('TTFM_WARNING', {
          sessionId: trackingData.sessionId,
          elapsedTime,
          milestone
        })
      }
    }
  }

  /**
   * 监听用户交互行为
   */
  private observeUserActions(trackingData: any) {
    const trackAction = (action: string, element?: string) => {
      const timestamp = performance.now()
      trackingData.userActions.push({
        action,
        element,
        timestamp,
        elapsedTime: timestamp - trackingData.startTime
      })

      // 记录关键动作里程碑
      switch (action) {
        case 'character_click':
          this.trackMilestone(trackingData, 'character_selected', timestamp)
          break
        case 'chat_start':
          this.trackMilestone(trackingData, 'chat_initiated', timestamp)
          break
        case 'message_send':
          this.trackMilestone(trackingData, 'first_message_sent', timestamp)
          break
        case 'message_received':
          this.completeTTFMTracking(trackingData, timestamp)
          break
      }
    }

    // 绑定事件监听器
    document.addEventListener('click', (e) => {
      const target = e.target as HTMLElement
      if (target.closest('.character-card')) {
        trackAction('character_click', target.closest('.character-card')?.id)
      } else if (target.closest('.chat-start-btn')) {
        trackAction('chat_start')
      } else if (target.closest('.message-send-btn')) {
        trackAction('message_send')
      }
    })

    // 监听WebSocket消息接收
    window.addEventListener('message-received', () => {
      trackAction('message_received')
    })
  }

  /**
   * 完成TTFM跟踪
   */
  private completeTTFMTracking(trackingData: any, endTime: number) {
    const ttfm = endTime - trackingData.startTime
    const sessionData = {
      sessionId: trackingData.sessionId,
      ttfm,
      milestones: Object.fromEntries(trackingData.milestones),
      userActions: trackingData.userActions,
      breakdown: this.calculateTTFMBreakdown(trackingData)
    }

    // 记录指标
    this.recordMetric('TTFM', ttfm, {
      target: 30000, // 目标30秒
      critical: 45000 // 严重阈值45秒
    })

    // 发送到分析服务
    this.analyticsReporter.reportTTFM(sessionData)

    // 检查是否需要告警
    if (ttfm > 30000) {
      this.alertingService.sendAlert('TTFM_EXCEEDED', sessionData)
    }

    // 清理事件监听器
    this.cleanupTTFMTracking(trackingData.sessionId)
  }

  /**
   * 计算TTFM时间分解
   */
  private calculateTTFMBreakdown(trackingData: any) {
    const milestones = trackingData.milestones
    const startTime = trackingData.startTime

    return {
      pageLoad: milestones.get('page_load') - startTime,
      characterBrowsing: milestones.get('character_selected') - milestones.get('page_load'),
      chatInitiation: milestones.get('chat_initiated') - milestones.get('character_selected'),
      messageComposition: milestones.get('first_message_sent') - milestones.get('chat_initiated'),
      aiResponse: milestones.get('first_message_received') - milestones.get('first_message_sent')
    }
  }

  /**
   * 监控API性能
   */
  observeAPIPerformance() {
    const originalFetch = window.fetch

    window.fetch = async (...args) => {
      const startTime = performance.now()
      const url = args[0].toString()

      try {
        const response = await originalFetch(...args)
        const endTime = performance.now()
        const duration = endTime - startTime

        this.recordAPIMetric(url, duration, response.status, response.ok)

        return response
      } catch (error) {
        const endTime = performance.now()
        const duration = endTime - startTime

        this.recordAPIMetric(url, duration, 0, false, error)
        throw error
      }
    }
  }

  /**
   * 记录API性能指标
   */
  private recordAPIMetric(url: string, duration: number, status: number, success: boolean, error?: any) {
    const endpoint = this.extractEndpoint(url)

    this.metricsCollector.recordAPICall({
      endpoint,
      duration,
      status,
      success,
      error: error?.message,
      timestamp: Date.now()
    })

    // 检查性能阈值
    const thresholds = this.getAPIThresholds(endpoint)
    if (duration > thresholds.warning) {
      this.alertingService.sendAlert('API_SLOW', {
        endpoint,
        duration,
        threshold: thresholds.warning
      })
    }

    if (!success) {
      this.alertingService.sendAlert('API_ERROR', {
        endpoint,
        status,
        error: error?.message
      })
    }
  }

  /**
   * 获取API性能阈值
   */
  private getAPIThresholds(endpoint: string) {
    const defaultThresholds = { warning: 2000, critical: 5000 }

    const endpointThresholds = {
      '/api/characters': { warning: 1000, critical: 3000 },
      '/api/chat/send': { warning: 3000, critical: 8000 },
      '/api/ai/generate': { warning: 5000, critical: 15000 },
      '/api/auth/login': { warning: 1500, critical: 4000 }
    }

    return endpointThresholds[endpoint] || defaultThresholds
  }

  /**
   * 记录性能指标
   */
  private recordMetric(name: string, value: number, thresholds: { target: number; critical: number }) {
    const metric = {
      name,
      value,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight
      },
      connection: this.getConnectionInfo()
    }

    this.metricsCollector.record(metric)

    // 检查阈值并发送告警
    if (value > thresholds.critical) {
      this.alertingService.sendAlert('PERFORMANCE_CRITICAL', { metric, threshold: thresholds.critical })
    } else if (value > thresholds.target) {
      this.alertingService.sendAlert('PERFORMANCE_WARNING', { metric, threshold: thresholds.target })
    }
  }

  /**
   * 获取网络连接信息
   */
  private getConnectionInfo() {
    const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection

    if (connection) {
      return {
        effectiveType: connection.effectiveType,
        downlink: connection.downlink,
        rtt: connection.rtt,
        saveData: connection.saveData
      }
    }

    return null
  }
}
```

#### 2. E2ETestSuite.ts - 端到端测试套件
```typescript
// tests/e2e/E2ETestSuite.ts
import { test, expect, Page } from '@playwright/test'

export class TavernAIE2ETestSuite {
  private page: Page
  private performanceMetrics: Map<string, number> = new Map()

  constructor(page: Page) {
    this.page = page
  }

  /**
   * 完整的TTFM测试流程
   */
  async testTTFMFlow(userType: 'new' | 'returning' = 'new') {
    const startTime = Date.now()

    // 1. 页面加载测试
    await this.testPageLoad(startTime)

    // 2. 角色发现测试
    await this.testCharacterDiscovery(startTime)

    // 3. 角色选择测试
    await this.testCharacterSelection(startTime)

    // 4. 对话启动测试
    await this.testChatInitiation(startTime)

    // 5. 首次消息测试
    const ttfm = await this.testFirstMessage(startTime)

    // 验证TTFM目标
    expect(ttfm).toBeLessThan(30000) // 30秒目标

    return {
      ttfm,
      breakdown: this.performanceMetrics,
      userType
    }
  }

  /**
   * 测试页面加载性能
   */
  private async testPageLoad(startTime: number) {
    await this.page.goto('/', { waitUntil: 'networkidle' })

    // 等待关键元素加载
    await this.page.waitForSelector('.character-grid-masonry', { timeout: 5000 })

    const loadTime = Date.now() - startTime
    this.performanceMetrics.set('pageLoad', loadTime)

    // 验证FCP
    const fcp = await this.page.evaluate(() => {
      return new Promise<number>((resolve) => {
        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.name === 'first-contentful-paint') {
              resolve(entry.startTime)
            }
          }
        }).observe({ entryTypes: ['paint'] })
      })
    })

    expect(fcp).toBeLessThan(1500) // FCP < 1.5秒
  }

  /**
   * 测试角色发现体验
   */
  private async testCharacterDiscovery(startTime: number) {
    // 验证角色卡片渲染
    const characterCards = await this.page.$$('.character-card-simple')
    expect(characterCards.length).toBeGreaterThan(0)

    // 测试搜索功能
    await this.page.fill('.smart-search-bar input', '测试角色')
    await this.page.waitForSelector('.character-card-simple:first-child', { timeout: 3000 })

    // 测试筛选功能
    await this.page.click('.filter-panel .filter-tag:first-child')
    await this.page.waitForSelector('.character-card-simple:first-child', { timeout: 3000 })

    const discoveryTime = Date.now() - startTime
    this.performanceMetrics.set('characterDiscovery', discoveryTime)
  }

  /**
   * 测试角色选择过程
   */
  private async testCharacterSelection(startTime: number) {
    // 选择第一个角色
    await this.page.click('.character-card-simple:first-child')

    // 验证角色详情加载
    await this.page.waitForSelector('.character-details', { timeout: 3000 })

    // 验证开始对话按钮
    const chatButton = await this.page.$('.start-chat-button')
    expect(chatButton).toBeTruthy()

    const selectionTime = Date.now() - startTime
    this.performanceMetrics.set('characterSelection', selectionTime)
  }

  /**
   * 测试对话启动过程
   */
  private async testChatInitiation(startTime: number) {
    // 点击开始对话
    await this.page.click('.start-chat-button')

    // 等待聊天界面加载
    await this.page.waitForSelector('.chat-interface-minimal', { timeout: 5000 })

    // 验证关键UI元素
    const messageInput = await this.page.$('.message-input')
    const sendButton = await this.page.$('.send-button')

    expect(messageInput).toBeTruthy()
    expect(sendButton).toBeTruthy()

    const initiationTime = Date.now() - startTime
    this.performanceMetrics.set('chatInitiation', initiationTime)
  }

  /**
   * 测试首次消息发送和接收
   */
  private async testFirstMessage(startTime: number): Promise<number> {
    // 输入测试消息
    await this.page.fill('.message-input', '你好，很高兴认识你！')

    // 发送消息
    await this.page.click('.send-button')

    // 等待AI响应
    await this.page.waitForSelector('.message-item.ai-message', { timeout: 15000 })

    const ttfm = Date.now() - startTime
    this.performanceMetrics.set('firstMessage', ttfm)

    // 验证消息内容
    const aiMessage = await this.page.textContent('.message-item.ai-message .message-content')
    expect(aiMessage).toBeTruthy()
    expect(aiMessage!.length).toBeGreaterThan(10)

    return ttfm
  }

  /**
   * 测试性能回归
   */
  async testPerformanceRegression() {
    const baselineMetrics = await this.loadBaselineMetrics()
    const currentMetrics = await this.collectCurrentMetrics()

    const regressions = []

    for (const [metric, baseline] of baselineMetrics) {
      const current = currentMetrics.get(metric)
      if (current && current > baseline * 1.1) { // 10%回归阈值
        regressions.push({
          metric,
          baseline,
          current,
          regression: ((current - baseline) / baseline * 100).toFixed(2) + '%'
        })
      }
    }

    if (regressions.length > 0) {
      console.warn('性能回归检测:', regressions)
      throw new Error(`检测到性能回归: ${regressions.map(r => r.metric).join(', ')}`)
    }

    return { passed: true, metrics: currentMetrics }
  }

  /**
   * 测试移动端性能
   */
  async testMobilePerformance() {
    // 模拟移动设备
    await this.page.setViewport({ width: 375, height: 667 })

    const mobileStartTime = Date.now()

    // 执行移动端TTFM测试
    const mobileTTFM = await this.testTTFMFlow('new')

    // 移动端性能要求稍宽松
    expect(mobileTTFM.ttfm).toBeLessThan(35000) // 35秒目标

    // 测试触控交互
    await this.testTouchInteractions()

    return mobileTTFM
  }

  /**
   * 测试触控交互
   */
  private async testTouchInteractions() {
    // 测试滑动手势
    await this.page.touchscreen.swipe(300, 400, 100, 400)

    // 验证侧边栏打开
    await this.page.waitForSelector('.mobile-sidebar.open', { timeout: 2000 })

    // 测试长按手势
    await this.page.touchscreen.touchStart(200, 300)
    await this.page.waitForTimeout(600)
    await this.page.touchscreen.touchEnd()

    // 验证上下文菜单
    await this.page.waitForSelector('.context-menu', { timeout: 2000 })
  }

  /**
   * 加载基准性能指标
   */
  private async loadBaselineMetrics(): Promise<Map<string, number>> {
    // 从文件或数据库加载基准指标
    const baseline = new Map([
      ['pageLoad', 1200],
      ['characterDiscovery', 800],
      ['characterSelection', 500],
      ['chatInitiation', 1000],
      ['firstMessage', 5000],
      ['ttfm', 8500]
    ])

    return baseline
  }

  /**
   * 收集当前性能指标
   */
  private async collectCurrentMetrics(): Promise<Map<string, number>> {
    // 执行标准测试流程并收集指标
    await this.testTTFMFlow()
    return this.performanceMetrics
  }
}

// 主要测试用例
test.describe('TavernAI Plus 性能测试', () => {
  let testSuite: TavernAIE2ETestSuite

  test.beforeEach(async ({ page }) => {
    testSuite = new TavernAIE2ETestSuite(page)
  })

  test('新用户TTFM应该小于30秒', async () => {
    const result = await testSuite.testTTFMFlow('new')
    expect(result.ttfm).toBeLessThan(30000)
  })

  test('返回用户TTFM应该小于20秒', async () => {
    // 模拟缓存和本地存储
    await testSuite.page.evaluate(() => {
      localStorage.setItem('user-preferences', JSON.stringify({
        favoriteCharacters: ['char-1', 'char-2'],
        lastVisited: Date.now() - 24 * 60 * 60 * 1000
      }))
    })

    const result = await testSuite.testTTFMFlow('returning')
    expect(result.ttfm).toBeLessThan(20000)
  })

  test('移动端性能应该满足要求', async () => {
    const result = await testSuite.testMobilePerformance()
    expect(result.ttfm).toBeLessThan(35000)
  })

  test('不应该存在性能回归', async () => {
    const result = await testSuite.testPerformanceRegression()
    expect(result.passed).toBe(true)
  })

  test('Core Web Vitals应该达标', async ({ page }) => {
    await page.goto('/')

    const webVitals = await page.evaluate(() => {
      return new Promise((resolve) => {
        const vitals = {}

        // 收集LCP
        new PerformanceObserver((list) => {
          const entries = list.getEntries()
          vitals.lcp = entries[entries.length - 1].startTime
        }).observe({ entryTypes: ['largest-contentful-paint'] })

        // 收集CLS
        let clsValue = 0
        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (!entry.hadRecentInput) {
              clsValue += entry.value
            }
          }
          vitals.cls = clsValue
        }).observe({ entryTypes: ['layout-shift'] })

        // 收集FID
        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            vitals.fid = entry.processingStart - entry.startTime
          }
          resolve(vitals)
        }).observe({ entryTypes: ['first-input'] })

        // 模拟用户交互触发FID
        setTimeout(() => {
          document.body.click()
        }, 1000)
      })
    })

    expect(webVitals.lcp).toBeLessThan(2500)
    expect(webVitals.cls).toBeLessThan(0.1)
    expect(webVitals.fid).toBeLessThan(100)
  })
})
```

#### 3. QualityAssuranceFramework.ts - 质量保证框架
```typescript
// services/qualityAssuranceFramework.ts
export class QualityAssuranceFramework {
  private testResults: Map<string, TestResult> = new Map()
  private qualityGates: QualityGate[]
  private reportGenerator: ReportGenerator

  constructor() {
    this.qualityGates = this.initializeQualityGates()
    this.reportGenerator = new ReportGenerator()
  }

  /**
   * 初始化质量门禁
   */
  private initializeQualityGates(): QualityGate[] {
    return [
      {
        name: 'TTFM性能',
        type: 'performance',
        conditions: [
          { metric: 'ttfm', operator: '<', value: 30000, critical: true },
          { metric: 'pageLoad', operator: '<', value: 2000, critical: false },
          { metric: 'apiResponse', operator: '<', value: 3000, critical: false }
        ]
      },
      {
        name: 'Core Web Vitals',
        type: 'webvitals',
        conditions: [
          { metric: 'FCP', operator: '<', value: 1500, critical: true },
          { metric: 'LCP', operator: '<', value: 2500, critical: true },
          { metric: 'CLS', operator: '<', value: 0.1, critical: true },
          { metric: 'FID', operator: '<', value: 100, critical: true }
        ]
      },
      {
        name: '功能完整性',
        type: 'functional',
        conditions: [
          { metric: 'characterBrowsing', operator: '=', value: 'pass', critical: true },
          { metric: 'chatFunctionality', operator: '=', value: 'pass', critical: true },
          { metric: 'aiIntegration', operator: '=', value: 'pass', critical: true },
          { metric: 'mobileCompatibility', operator: '=', value: 'pass', critical: false }
        ]
      },
      {
        name: '用户体验',
        type: 'ux',
        conditions: [
          { metric: 'userSatisfaction', operator: '>', value: 4.0, critical: false },
          { metric: 'taskCompletion', operator: '>', value: 0.9, critical: true },
          { metric: 'errorRate', operator: '<', value: 0.01, critical: true }
        ]
      }
    ]
  }

  /**
   * 执行完整质量检查
   */
  async runQualityCheck(): Promise<QualityReport> {
    const report: QualityReport = {
      timestamp: new Date(),
      overallScore: 0,
      gateResults: [],
      recommendations: [],
      criticalIssues: []
    }

    // 执行所有质量门禁检查
    for (const gate of this.qualityGates) {
      const gateResult = await this.checkQualityGate(gate)
      report.gateResults.push(gateResult)

      if (!gateResult.passed && gateResult.hasCriticalFailures) {
        report.criticalIssues.push(...gateResult.failures.filter(f => f.critical))
      }
    }

    // 计算总体评分
    report.overallScore = this.calculateOverallScore(report.gateResults)

    // 生成改进建议
    report.recommendations = this.generateRecommendations(report.gateResults)

    // 保存报告
    await this.saveQualityReport(report)

    return report
  }

  /**
   * 检查单个质量门禁
   */
  private async checkQualityGate(gate: QualityGate): Promise<QualityGateResult> {
    const result: QualityGateResult = {
      name: gate.name,
      type: gate.type,
      passed: true,
      score: 0,
      failures: [],
      hasCriticalFailures: false
    }

    const passedConditions = []
    const failedConditions = []

    for (const condition of gate.conditions) {
      const conditionResult = await this.evaluateCondition(condition)

      if (conditionResult.passed) {
        passedConditions.push(conditionResult)
      } else {
        failedConditions.push(conditionResult)
        result.failures.push(conditionResult)

        if (condition.critical) {
          result.hasCriticalFailures = true
          result.passed = false
        }
      }
    }

    // 计算门禁评分
    result.score = passedConditions.length / gate.conditions.length

    return result
  }

  /**
   * 评估单个条件
   */
  private async evaluateCondition(condition: QualityCondition): Promise<ConditionResult> {
    const actualValue = await this.getMetricValue(condition.metric)
    const passed = this.compareValues(actualValue, condition.operator, condition.value)

    return {
      metric: condition.metric,
      expected: condition.value,
      actual: actualValue,
      operator: condition.operator,
      passed,
      critical: condition.critical,
      message: this.generateConditionMessage(condition, actualValue, passed)
    }
  }

  /**
   * 获取指标值
   */
  private async getMetricValue(metric: string): Promise<any> {
    switch (metric) {
      case 'ttfm':
        return await this.measureTTFM()

      case 'FCP':
        return await this.measureFCP()

      case 'LCP':
        return await this.measureLCP()

      case 'CLS':
        return await this.measureCLS()

      case 'FID':
        return await this.measureFID()

      case 'characterBrowsing':
        return await this.testCharacterBrowsing()

      case 'chatFunctionality':
        return await this.testChatFunctionality()

      case 'aiIntegration':
        return await this.testAIIntegration()

      case 'mobileCompatibility':
        return await this.testMobileCompatibility()

      case 'userSatisfaction':
        return await this.getUserSatisfactionScore()

      case 'taskCompletion':
        return await this.getTaskCompletionRate()

      case 'errorRate':
        return await this.getErrorRate()

      default:
        throw new Error(`未知指标: ${metric}`)
    }
  }

  /**
   * 测量TTFM
   */
  private async measureTTFM(): Promise<number> {
    // 实际测量TTFM的逻辑
    return new Promise((resolve) => {
      const startTime = performance.now()

      // 模拟完整用户流程
      this.simulateUserJourney().then(() => {
        const ttfm = performance.now() - startTime
        resolve(ttfm)
      })
    })
  }

  /**
   * 模拟用户旅程
   */
  private async simulateUserJourney(): Promise<void> {
    // 自动化用户行为模拟
    await this.simulatePageLoad()
    await this.simulateCharacterSelection()
    await this.simulateChatInitiation()
    await this.simulateFirstMessage()
  }

  /**
   * 计算总体评分
   */
  private calculateOverallScore(gateResults: QualityGateResult[]): number {
    if (gateResults.length === 0) return 0

    const weights = {
      'performance': 0.3,
      'webvitals': 0.25,
      'functional': 0.3,
      'ux': 0.15
    }

    let weightedScore = 0
    let totalWeight = 0

    for (const result of gateResults) {
      const weight = weights[result.type] || 0.1
      weightedScore += result.score * weight
      totalWeight += weight
    }

    return Math.round((weightedScore / totalWeight) * 100)
  }

  /**
   * 生成改进建议
   */
  private generateRecommendations(gateResults: QualityGateResult[]): Recommendation[] {
    const recommendations: Recommendation[] = []

    for (const result of gateResults) {
      if (!result.passed || result.score < 0.8) {
        recommendations.push(...this.getGateRecommendations(result))
      }
    }

    return recommendations.sort((a, b) => b.priority - a.priority)
  }

  /**
   * 获取特定门禁的建议
   */
  private getGateRecommendations(gateResult: QualityGateResult): Recommendation[] {
    const recommendations: Recommendation[] = []

    switch (gateResult.type) {
      case 'performance':
        if (gateResult.failures.some(f => f.metric === 'ttfm')) {
          recommendations.push({
            title: '优化TTFM性能',
            description: '考虑减少API调用、优化组件渲染、改进缓存策略',
            priority: 9,
            category: 'performance',
            estimatedImpact: 'high'
          })
        }
        break

      case 'webvitals':
        if (gateResult.failures.some(f => f.metric === 'LCP')) {
          recommendations.push({
            title: '优化最大内容绘制',
            description: '优化关键资源加载，使用更高效的图片格式',
            priority: 8,
            category: 'webvitals',
            estimatedImpact: 'high'
          })
        }
        break

      case 'functional':
        recommendations.push({
          title: '修复功能缺陷',
          description: '检查并修复失败的功能测试用例',
          priority: 10,
          category: 'functional',
          estimatedImpact: 'critical'
        })
        break

      case 'ux':
        recommendations.push({
          title: '改进用户体验',
          description: '分析用户反馈，优化交互流程',
          priority: 6,
          category: 'ux',
          estimatedImpact: 'medium'
        })
        break
    }

    return recommendations
  }

  /**
   * 保存质量报告
   */
  private async saveQualityReport(report: QualityReport): Promise<void> {
    const reportId = `qa-report-${Date.now()}`

    // 保存到数据库
    await this.reportGenerator.saveReport(reportId, report)

    // 生成可视化报告
    await this.reportGenerator.generateVisualReport(report)

    // 发送通知
    if (report.criticalIssues.length > 0) {
      await this.sendCriticalIssueAlert(report)
    }
  }

  /**
   * 发送关键问题告警
   */
  private async sendCriticalIssueAlert(report: QualityReport): Promise<void> {
    const alertData = {
      severity: 'critical',
      title: '质量门禁检测到关键问题',
      description: `检测到 ${report.criticalIssues.length} 个关键问题`,
      issues: report.criticalIssues,
      overallScore: report.overallScore,
      timestamp: report.timestamp
    }

    // 发送到监控系统
    await this.sendAlert(alertData)
  }
}
```

## 验收标准

### 性能监控验收标准
- [ ] **TTFM监控完整**：能准确追踪并分析30秒TTFM目标的达成情况
- [ ] **Core Web Vitals监控**：实时监控FCP、LCP、CLS、FID等关键指标
- [ ] **API性能监控**：监控所有关键API的响应时间和成功率
- [ ] **实时告警机制**：性能指标异常时能及时发送告警通知
- [ ] **性能趋势分析**：提供历史性能数据的趋势分析和预测

### 自动化测试验收标准
- [ ] **E2E测试覆盖完整**：覆盖所有关键用户流程和业务场景
- [ ] **性能回归检测**：能自动检测并报告性能回归问题
- [ ] **多环境测试支持**：支持桌面端、移动端、不同浏览器的测试
- [ ] **测试结果可视化**：提供清晰的测试报告和结果可视化
- [ ] **持续集成集成**：与CI/CD流水线完整集成

### 质量门禁验收标准
- [ ] **门禁条件合理**：质量门禁条件既严格又现实可达
- [ ] **自动化评估**：质量评估过程完全自动化，无需人工干预
- [ ] **评分系统准确**：质量评分能准确反映系统的真实质量状况
- [ ] **改进建议实用**：系统生成的改进建议具有实际指导价值
- [ ] **关键问题识别**：能准确识别并优先处理关键质量问题

### 用户体验监控验收标准
- [ ] **真实用户监控**：收集真实用户的性能和体验数据
- [ ] **用户满意度追踪**：定期收集并分析用户满意度反馈
- [ ] **任务完成率统计**：准确统计用户核心任务的完成情况
- [ ] **错误率监控**：监控并分析用户遇到的各类错误
- [ ] **体验优化建议**：基于数据分析提供体验优化建议

### 报告和可视化验收标准
- [ ] **报告内容完整**：包含性能、功能、用户体验等全方位质量信息
- [ ] **可视化清晰**：图表和数据展示清晰易懂，支持钻取分析
- [ ] **定制化能力**：支持不同角色和需求的定制化报告
- [ ] **历史数据对比**：提供历史数据对比和趋势分析功能
- [ ] **导出分享功能**：支持报告的导出和分享功能

## 实施细节

### 文件结构
```
apps/web/src/
├── services/monitoring/
│   ├── performanceMonitor.ts           # 性能监控服务
│   ├── qualityAssurance.ts             # 质量保证框架
│   ├── metricsCollector.ts              # 指标收集器
│   └── alertingService.ts               # 告警服务
├── tests/e2e/
│   ├── ttfm.spec.ts                    # TTFM测试用例
│   ├── performance.spec.ts             # 性能测试用例
│   ├── quality-gates.spec.ts           # 质量门禁测试
│   └── user-experience.spec.ts         # 用户体验测试
├── tests/load/
│   ├── character-browsing.js           # 角色浏览压力测试
│   ├── chat-performance.js             # 聊天性能测试
│   └── api-load-test.js                # API负载测试
├── utils/testing/
│   ├── testDataGenerator.ts            # 测试数据生成器
│   ├── mockServices.ts                 # 模拟服务
│   └── performanceHelpers.ts           # 性能测试辅助工具
└── reports/
    ├── performance-dashboard.html       # 性能仪表板
    ├── quality-report-template.html     # 质量报告模板
    └── user-experience-analytics.html   # 用户体验分析
```

### 监控配置文件
```yaml
# monitoring-config.yml
performance_monitoring:
  ttfm:
    target: 30000  # 30秒目标
    warning: 25000 # 25秒警告
    critical: 40000 # 40秒严重

  core_web_vitals:
    fcp:
      target: 1500
      critical: 2500
    lcp:
      target: 2500
      critical: 4000
    cls:
      target: 0.1
      critical: 0.25
    fid:
      target: 100
      critical: 300

  api_performance:
    endpoints:
      - path: "/api/characters"
        timeout: 3000
        warning: 1000
      - path: "/api/chat/send"
        timeout: 8000
        warning: 3000
      - path: "/api/ai/generate"
        timeout: 15000
        warning: 5000

quality_gates:
  - name: "Performance Gate"
    required: true
    conditions:
      - metric: "ttfm"
        operator: "<"
        value: 30000
      - metric: "error_rate"
        operator: "<"
        value: 0.01

  - name: "Web Vitals Gate"
    required: true
    conditions:
      - metric: "lcp"
        operator: "<"
        value: 2500
      - metric: "cls"
        operator: "<"
        value: 0.1

alerting:
  channels:
    - type: "slack"
      webhook: "${SLACK_WEBHOOK_URL}"
    - type: "email"
      recipients: ["dev-team@company.com"]
    - type: "sms"
      numbers: ["+1234567890"]

  rules:
    - name: "TTFM Exceeded"
      condition: "ttfm > 30000"
      severity: "critical"
      channels: ["slack", "email"]

    - name: "API Error Rate High"
      condition: "api_error_rate > 0.05"
      severity: "warning"
      channels: ["slack"]
```

### CI/CD集成配置
```yaml
# .github/workflows/quality-assurance.yml
name: Quality Assurance

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  performance-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Start test server
        run: npm run start:test &

      - name: Wait for server
        run: npx wait-on http://localhost:3000

      - name: Run E2E performance tests
        run: npx playwright test tests/e2e/performance.spec.ts

      - name: Run TTFM tests
        run: npx playwright test tests/e2e/ttfm.spec.ts

      - name: Quality gate check
        run: npm run quality:check

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: test-results/

      - name: Performance report
        run: npm run performance:report

      - name: Comment PR with results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs')
            const report = fs.readFileSync('performance-report.md', 'utf8')
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: report
            })
```

## Definition of Done

### 监控系统检查清单
- [ ] **性能监控完整部署**：所有关键性能指标实时监控并记录
- [ ] **告警机制正常工作**：性能异常时能及时准确发送告警
- [ ] **数据收集准确**：监控数据准确反映系统真实性能状况
- [ ] **历史数据完整**：保留足够的历史数据支持趋势分析
- [ ] **监控覆盖全面**：覆盖前端、后端、API、数据库等各层面

### 测试框架检查清单
- [ ] **E2E测试覆盖完整**：所有关键用户流程都有自动化测试覆盖
- [ ] **测试执行稳定**：测试用例执行稳定，结果可重现
- [ ] **性能基准建立**：建立明确的性能基准和回归检测机制
- [ ] **多环境支持**：支持开发、测试、生产等多环境测试
- [ ] **CI/CD集成完整**：与构建流水线完全集成，自动执行

### 质量门禁检查清单
- [ ] **门禁条件科学**：质量门禁条件基于实际需求和技术可行性
- [ ] **评估过程自动化**：质量评估过程完全自动化，结果客观准确
- [ ] **问题识别精准**：能准确识别真正影响用户体验的质量问题
- [ ] **改进建议实用**：生成的改进建议具有明确的执行路径
- [ ] **报告产出及时**：质量报告及时生成并分发给相关团队

### 用户体验监控检查清单
- [ ] **真实用户数据收集**：收集真实用户的使用数据和反馈
- [ ] **体验指标完整**：涵盖性能、功能、满意度等多维度体验指标
- [ ] **数据分析深入**：能深入分析用户行为和体验痛点
- [ ] **优化建议具体**：基于数据分析提供具体可执行的优化建议
- [ ] **效果跟踪完整**：能跟踪优化措施的实际效果

### 部署和维护检查清单
- [ ] **部署流程标准化**：监控和测试系统的部署流程标准化
- [ ] **配置管理规范**：监控配置和测试用例的版本管理规范
- [ ] **运维文档完善**：包含部署、配置、故障排查等完整文档
- [ ] **权限管理安全**：监控数据和报告的访问权限管理安全
- [ ] **数据备份完整**：重要监控数据和测试结果的备份机制完整

---

*本任务是TavernAI Plus "创世纪"计划的最终验收环节，通过建立完整的性能监控、自动化测试和质量保证体系，确保项目达到预期的技术指标和用户体验目标。这个质量保证框架将为项目的长期成功和持续改进提供坚实的基础。*