---
name: "AI角色生成增强"
status: pending
created: 2025-09-21T02:07:42Z
updated: 2025-09-21T02:36:29Z
github: https://github.com/miounet11/jiuguanbaba/issues/14
depends_on: []
parallel: true
conflicts_with: []
estimated_effort: M
estimated_hours: 32
epic: tavernai-plus-upgrade
tags: ["ai-generation", "character-creation", "nano-banana", "multimodal-ai"]
---

# Task 004: AI角色生成增强

## 概述

集成nano-banana服务，完善现有character-generator服务，实现智能化的角色创建体验。通过增强AI图像生成能力、优化角色属性生成算法、引入多模态AI协作，将角色创建从手工制作转向AI辅助的智能生成模式。

## 目标

- 集成nano-banana图像生成服务，提升角色头像质量
- 完善现有character-generator服务的生成逻辑
- 实现多模态AI协作的角色创建流程
- 优化角色属性的智能推理和生成
- 建立角色质量评估和优化机制

## 技术要求

### 核心服务增强

#### 1. multimodalAI.ts 增强 - 集成nano-banana
```typescript
// services/multimodalAI.ts - 扩展现有服务
export class MultimodalAIService {
  private nanoBananaClient: NanoBananaClient
  private characterGenerator: CharacterGeneratorService

  constructor() {
    this.nanoBananaClient = new NanoBananaClient({
      apiKey: process.env.NANO_BANANA_API_KEY,
      baseURL: process.env.NANO_BANANA_BASE_URL
    })

    this.characterGenerator = new CharacterGeneratorService()
  }

  /**
   * 生成角色头像 - 新增功能
   */
  async generateCharacterAvatar(params: {
    characterDescription: string
    style?: 'anime' | 'realistic' | 'artistic' | 'cartoon'
    gender?: 'male' | 'female' | 'non-binary'
    ageRange?: 'young' | 'adult' | 'mature'
    customPrompt?: string
  }): Promise<GeneratedAvatar> {
    try {
      // 构建优化的图像生成提示词
      const imagePrompt = this.buildAvatarPrompt(params)

      // 调用nano-banana生成图像
      const imageResult = await this.nanoBananaClient.generateImage({
        prompt: imagePrompt,
        model: this.selectOptimalImageModel(params.style),
        size: '512x512',
        quality: 'hd',
        style: params.style || 'anime'
      })

      // 后处理和优化
      const optimizedImage = await this.optimizeGeneratedImage(imageResult)

      return {
        id: generateId(),
        url: optimizedImage.url,
        originalUrl: imageResult.url,
        prompt: imagePrompt,
        metadata: {
          model: imageResult.model,
          generatedAt: new Date(),
          style: params.style,
          quality: optimizedImage.qualityScore
        }
      }

    } catch (error) {
      console.error('角色头像生成失败:', error)
      throw new EnhancedAIError('头像生成失败', error)
    }
  }

  /**
   * 智能角色完整生成 - 增强现有功能
   */
  async generateCompleteCharacter(input: {
    concept?: string
    genre?: string
    personality?: string[]
    userPreferences?: UserCharacterPreferences
  }): Promise<GeneratedCharacter> {
    try {
      // 步骤1: 生成基础角色属性
      const baseCharacter = await this.generateCharacterAttributes(input)

      // 步骤2: 生成角色头像
      const avatar = await this.generateCharacterAvatar({
        characterDescription: baseCharacter.description,
        style: this.inferImageStyle(input.genre),
        gender: baseCharacter.gender,
        ageRange: baseCharacter.ageRange
      })

      // 步骤3: 生成角色背景故事
      const backstory = await this.generateCharacterBackstory(baseCharacter)

      // 步骤4: 生成示例对话
      const sampleDialogues = await this.generateSampleDialogues(baseCharacter)

      // 步骤5: 质量评估和优化
      const qualityScore = await this.assessCharacterQuality({
        ...baseCharacter,
        avatar,
        backstory,
        sampleDialogues
      })

      return {
        ...baseCharacter,
        avatar,
        backstory,
        sampleDialogues,
        qualityScore,
        generatedAt: new Date(),
        generationMetadata: {
          totalGenerationTime: Date.now() - startTime,
          modelsUsed: this.getUsedModels(),
          version: '2.0'
        }
      }

    } catch (error) {
      console.error('完整角色生成失败:', error)
      throw new EnhancedAIError('角色生成失败', error)
    }
  }

  /**
   * 构建优化的头像生成提示词
   */
  private buildAvatarPrompt(params: AvatarGenerationParams): string {
    const basePrompt = this.parseCharacterDescription(params.characterDescription)

    const stylePrompts = {
      anime: 'anime style, high quality anime art, detailed character design',
      realistic: 'photorealistic, high detail, professional portrait',
      artistic: 'artistic style, painterly, expressive art',
      cartoon: 'cartoon style, friendly character design, colorful'
    }

    const qualityModifiers = [
      'high quality',
      'detailed',
      'professional',
      'best quality',
      'masterpiece'
    ]

    const negativePrompts = [
      'low quality',
      'blurry',
      'distorted',
      'extra limbs',
      'bad anatomy'
    ]

    return [
      basePrompt,
      stylePrompts[params.style || 'anime'],
      qualityModifiers.join(', '),
      `--negative ${negativePrompts.join(', ')}`
    ].join(', ')
  }

  /**
   * 选择最优图像生成模型
   */
  private selectOptimalImageModel(style?: string): string {
    const modelMap = {
      anime: 'anime-diffusion-xl',
      realistic: 'stable-diffusion-xl',
      artistic: 'artistic-diffusion',
      cartoon: 'cartoon-diffusion'
    }

    return modelMap[style || 'anime'] || 'anime-diffusion-xl'
  }

  /**
   * 图像后处理和优化
   */
  private async optimizeGeneratedImage(imageResult: ImageGenerationResult): Promise<OptimizedImage> {
    // 质量评估
    const qualityScore = await this.assessImageQuality(imageResult.url)

    // 如果质量不足，进行重新生成或优化
    if (qualityScore < 0.7) {
      return await this.enhanceImageQuality(imageResult)
    }

    // 图像压缩和格式优化
    const optimizedUrl = await this.compressAndOptimizeImage(imageResult.url)

    return {
      url: optimizedUrl,
      qualityScore,
      optimized: true
    }
  }
}
```

#### 2. character-generator.ts 完善 - 增强现有服务
```typescript
// services/character-generator.ts - 完善现有功能
export class CharacterGeneratorService {
  private llmService: LLMService
  private multimodalAI: MultimodalAIService

  /**
   * 生成角色基础属性 - 增强现有逻辑
   */
  async generateCharacterAttributes(input: CharacterGenerationInput): Promise<BaseCharacter> {
    // 构建智能提示词
    const prompt = this.buildCharacterPrompt(input)

    // 使用多模型协作生成
    const responses = await Promise.allSettled([
      this.llmService.generate({
        model: 'grok-3-32b',
        prompt,
        temperature: 0.8,
        maxTokens: 1500
      }),
      this.llmService.generate({
        model: 'claude-3-sonnet',
        prompt,
        temperature: 0.7,
        maxTokens: 1500
      })
    ])

    // 选择最佳响应或合并响应
    const bestResponse = this.selectBestCharacterResponse(responses)

    // 解析和验证生成的角色数据
    const parsedCharacter = this.parseCharacterResponse(bestResponse)

    // 智能属性补全和优化
    const enhancedCharacter = await this.enhanceCharacterAttributes(parsedCharacter, input)

    return enhancedCharacter
  }

  /**
   * 生成角色背景故事 - 新增功能
   */
  async generateCharacterBackstory(character: BaseCharacter): Promise<CharacterBackstory> {
    const backstoryPrompt = this.buildBackstoryPrompt(character)

    const backstory = await this.llmService.generate({
      model: 'gpt-4-turbo',
      prompt: backstoryPrompt,
      temperature: 0.75,
      maxTokens: 1000
    })

    return {
      fullBackstory: backstory,
      keyEvents: this.extractKeyEvents(backstory),
      relationships: this.extractRelationships(backstory),
      secrets: this.extractSecrets(backstory),
      motivations: this.extractMotivations(backstory)
    }
  }

  /**
   * 生成示例对话 - 新增功能
   */
  async generateSampleDialogues(character: BaseCharacter): Promise<SampleDialogue[]> {
    const dialogueScenarios = [
      '初次见面的问候',
      '日常闲聊场景',
      '深入个人话题',
      '处理冲突情况',
      '展示专业知识'
    ]

    const dialogues = await Promise.all(
      dialogueScenarios.map(scenario =>
        this.generateDialogueForScenario(character, scenario)
      )
    )

    return dialogues
  }

  /**
   * 角色质量评估 - 新增功能
   */
  async assessCharacterQuality(character: CompleteCharacter): Promise<QualityAssessment> {
    const assessmentCriteria = {
      consistency: await this.assessConsistency(character),
      creativity: await this.assessCreativity(character),
      realism: await this.assessRealism(character),
      engagement: await this.assessEngagement(character),
      completeness: await this.assessCompleteness(character)
    }

    const overallScore = Object.values(assessmentCriteria)
      .reduce((sum, score) => sum + score, 0) / Object.keys(assessmentCriteria).length

    return {
      overallScore,
      criteria: assessmentCriteria,
      recommendations: this.generateImprovementRecommendations(assessmentCriteria),
      passesQualityGate: overallScore >= 0.75
    }
  }

  /**
   * 智能提示词构建
   */
  private buildCharacterPrompt(input: CharacterGenerationInput): string {
    const basePrompt = `创建一个独特且吸引人的角色，要求如下：`

    const requirements = [
      input.concept && `概念: ${input.concept}`,
      input.genre && `类型: ${input.genre}`,
      input.personality && `性格特点: ${input.personality.join(', ')}`,
      '请包含：完整的姓名、年龄、外貌描述、性格特征、职业/身份、说话风格、兴趣爱好、独特特质'
    ].filter(Boolean)

    const formatInstructions = `
请以JSON格式返回，包含以下字段：
{
  "name": "角色名称",
  "age": "年龄",
  "gender": "性别",
  "appearance": "外貌描述",
  "personality": ["性格特点1", "性格特点2"],
  "occupation": "职业/身份",
  "speakingStyle": "说话风格描述",
  "interests": ["兴趣1", "兴趣2"],
  "uniqueTraits": ["独特特质1", "独特特质2"],
  "greeting": "角色的问候语",
  "description": "整体角色描述"
}
`

    return [basePrompt, ...requirements, formatInstructions].join('\n\n')
  }

  /**
   * 角色属性增强和优化
   */
  private async enhanceCharacterAttributes(
    character: ParsedCharacter,
    input: CharacterGenerationInput
  ): Promise<BaseCharacter> {

    // 属性一致性检查和修正
    const consistentCharacter = this.ensureAttributeConsistency(character)

    // 基于用户偏好的个性化调整
    const personalizedCharacter = this.applyUserPreferences(
      consistentCharacter,
      input.userPreferences
    )

    // 添加智能推理的隐性属性
    const enrichedCharacter = await this.addImplicitAttributes(personalizedCharacter)

    return enrichedCharacter
  }
}
```

### 前端界面组件

#### 1. CharacterGeneratorPanel.vue - 角色生成面板
```vue
<template>
  <div class="character-generator-panel">
    <!-- 生成配置区域 -->
    <div class="generator-config">
      <h3>AI角色生成器</h3>

      <el-form :model="generationConfig" label-width="100px">
        <el-form-item label="基础概念">
          <el-input
            v-model="generationConfig.concept"
            placeholder="例如：勇敢的女战士、温柔的图书管理员..."
            type="textarea"
            :rows="2"
          />
        </el-form-item>

        <el-form-item label="类型风格">
          <el-select v-model="generationConfig.genre" placeholder="选择类型">
            <el-option label="现代都市" value="modern" />
            <el-option label="奇幻冒险" value="fantasy" />
            <el-option label="科幻未来" value="sci-fi" />
            <el-option label="历史古风" value="historical" />
            <el-option label="日常生活" value="slice-of-life" />
          </el-select>
        </el-form-item>

        <el-form-item label="性格特点">
          <PersonalitySelector
            v-model="generationConfig.personality"
            :max-selections="5"
          />
        </el-form-item>

        <el-form-item label="头像风格">
          <el-radio-group v-model="generationConfig.avatarStyle">
            <el-radio-button value="anime">动漫风格</el-radio-button>
            <el-radio-button value="realistic">写实风格</el-radio-button>
            <el-radio-button value="artistic">艺术风格</el-radio-button>
            <el-radio-button value="cartoon">卡通风格</el-radio-button>
          </el-radio-group>
        </el-form-item>

        <el-form-item label="高级选项">
          <el-switch v-model="generationConfig.includeBackstory" active-text="包含背景故事" />
          <br/>
          <el-switch v-model="generationConfig.generateDialogues" active-text="生成示例对话" />
          <br/>
          <el-switch v-model="generationConfig.multipleVariants" active-text="生成多个变体" />
        </el-form-item>

        <el-form-item>
          <el-button
            type="primary"
            @click="generateCharacter"
            :loading="isGenerating"
            :disabled="!canGenerate"
            size="large"
          >
            <MagicStick />
            {{ isGenerating ? '正在生成...' : '生成角色' }}
          </el-button>
        </el-form-item>
      </el-form>
    </div>

    <!-- 生成进度显示 -->
    <div v-if="isGenerating" class="generation-progress">
      <el-progress :percentage="generationProgress" :status="progressStatus" />
      <p>{{ generationStage }}</p>
    </div>

    <!-- 生成结果展示 -->
    <div v-if="generatedCharacter" class="generation-result">
      <CharacterPreview
        :character="generatedCharacter"
        :quality-score="qualityAssessment?.overallScore"
        @regenerate-avatar="regenerateAvatar"
        @regenerate-attributes="regenerateAttributes"
        @save-character="saveCharacter"
      />

      <!-- 质量评估反馈 -->
      <QualityAssessmentPanel
        v-if="qualityAssessment"
        :assessment="qualityAssessment"
        @apply-improvements="applyImprovements"
      />
    </div>
  </div>
</template>
```

#### 2. CharacterPreview.vue - 角色预览组件
```vue
<template>
  <div class="character-preview">
    <div class="preview-header">
      <h4>生成的角色</h4>
      <div class="quality-indicator" v-if="qualityScore">
        <el-rate
          v-model="displayRating"
          disabled
          show-score
          text-color="#ff9900"
          score-template="质量: {value}"
        />
      </div>
    </div>

    <div class="character-content">
      <!-- 角色头像和基础信息 -->
      <div class="character-basic">
        <div class="avatar-section">
          <img :src="character.avatar.url" :alt="character.name" />
          <el-button size="small" @click="$emit('regenerate-avatar')">
            <Refresh />
            重新生成头像
          </el-button>
        </div>

        <div class="basic-info">
          <h3>{{ character.name }}</h3>
          <p class="age-gender">{{ character.age }}岁 · {{ character.gender }}</p>
          <p class="occupation">{{ character.occupation }}</p>

          <div class="personality-tags">
            <el-tag
              v-for="trait in character.personality"
              :key="trait"
              type="info"
              size="small"
            >
              {{ trait }}
            </el-tag>
          </div>
        </div>
      </div>

      <!-- 详细描述 -->
      <div class="character-details">
        <el-tabs v-model="activeTab">
          <el-tab-pane label="基础信息" name="basic">
            <div class="detail-section">
              <h5>外貌描述</h5>
              <p>{{ character.appearance }}</p>

              <h5>说话风格</h5>
              <p>{{ character.speakingStyle }}</p>

              <h5>兴趣爱好</h5>
              <ul>
                <li v-for="interest in character.interests" :key="interest">
                  {{ interest }}
                </li>
              </ul>
            </div>
          </el-tab-pane>

          <el-tab-pane label="背景故事" name="backstory" v-if="character.backstory">
            <div class="backstory-content">
              <p>{{ character.backstory.fullBackstory }}</p>

              <div class="key-elements">
                <div class="element-group" v-if="character.backstory.keyEvents.length">
                  <h6>关键事件</h6>
                  <ul>
                    <li v-for="event in character.backstory.keyEvents" :key="event">
                      {{ event }}
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </el-tab-pane>

          <el-tab-pane label="示例对话" name="dialogues" v-if="character.sampleDialogues">
            <div class="sample-dialogues">
              <div
                v-for="dialogue in character.sampleDialogues"
                :key="dialogue.scenario"
                class="dialogue-sample"
              >
                <h6>{{ dialogue.scenario }}</h6>
                <div class="dialogue-messages">
                  <div
                    v-for="message in dialogue.messages"
                    :key="message.id"
                    :class="['message', message.role]"
                  >
                    <strong>{{ message.role === 'user' ? '用户' : character.name }}：</strong>
                    {{ message.content }}
                  </div>
                </div>
              </div>
            </div>
          </el-tab-pane>
        </el-tabs>
      </div>

      <!-- 操作按钮 -->
      <div class="character-actions">
        <el-button @click="$emit('regenerate-attributes')">
          <Refresh />
          重新生成属性
        </el-button>
        <el-button type="primary" @click="$emit('save-character')">
          <Check />
          保存角色
        </el-button>
      </div>
    </div>
  </div>
</template>
```

### 性能优化和缓存策略

#### 1. 生成结果缓存
```typescript
// utils/generationCache.ts
export class CharacterGenerationCache {
  private cache = new Map<string, CachedGeneration>()
  private readonly maxCacheSize = 50
  private readonly cacheExpiry = 24 * 60 * 60 * 1000 // 24小时

  /**
   * 生成缓存键
   */
  private generateCacheKey(input: CharacterGenerationInput): string {
    return crypto
      .createHash('md5')
      .update(JSON.stringify(input))
      .digest('hex')
  }

  /**
   * 获取缓存的生成结果
   */
  getCachedGeneration(input: CharacterGenerationInput): GeneratedCharacter | null {
    const key = this.generateCacheKey(input)
    const cached = this.cache.get(key)

    if (!cached || Date.now() - cached.timestamp > this.cacheExpiry) {
      this.cache.delete(key)
      return null
    }

    // 更新访问时间
    cached.lastAccessed = Date.now()
    return cached.character
  }

  /**
   * 缓存生成结果
   */
  cacheGeneration(input: CharacterGenerationInput, character: GeneratedCharacter): void {
    const key = this.generateCacheKey(input)

    // 如果缓存已满，删除最旧的条目
    if (this.cache.size >= this.maxCacheSize) {
      this.evictOldestEntry()
    }

    this.cache.set(key, {
      character,
      timestamp: Date.now(),
      lastAccessed: Date.now()
    })
  }

  /**
   * 驱逐最旧的条目
   */
  private evictOldestEntry(): void {
    let oldestKey = ''
    let oldestTime = Date.now()

    for (const [key, cached] of this.cache.entries()) {
      if (cached.lastAccessed < oldestTime) {
        oldestTime = cached.lastAccessed
        oldestKey = key
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey)
    }
  }
}
```

## 验收标准

### AI生成质量验收标准
- [ ] **头像生成质量高**：nano-banana生成的头像质量评分>0.8，风格一致性好
- [ ] **角色属性完整**：生成的角色包含所有必需属性，信息丰富且逻辑一致
- [ ] **背景故事合理**：角色背景故事与其他属性匹配，有说服力和趣味性
- [ ] **示例对话真实**：生成的对话符合角色性格，自然流畅
- [ ] **多样性保证**：相同输入生成的角色具有足够的差异性和创意

### 技术集成验收标准
- [ ] **nano-banana集成正常**：图像生成API调用成功，错误处理完善
- [ ] **现有服务增强**：multimodalAI和character-generator服务功能正确扩展
- [ ] **多模型协作有效**：不同AI模型协作生成效果好于单一模型
- [ ] **缓存机制正常**：生成结果正确缓存，提升重复生成效率
- [ ] **质量评估准确**：AI角色质量评估机制能准确识别优质角色

### 用户体验验收标准
- [ ] **生成流程直观**：界面清晰，用户能轻松理解和操作生成流程
- [ ] **进度反馈及时**：生成过程有清晰的进度指示和状态更新
- [ ] **结果展示完整**：生成结果以易读的方式完整展示所有信息
- [ ] **再生成便捷**：用户可以方便地重新生成部分或全部内容
- [ ] **保存流程简单**：生成的角色可以一键保存到角色库

## 实施细节

### 文件结构
```
apps/api/src/services/
├── multimodalAI.ts                     # 增强现有多模态AI服务
├── character-generator.ts              # 完善角色生成器服务
├── nanoBananaClient.ts                 # nano-banana客户端
└── characterQuality.ts                 # 角色质量评估服务

apps/web/src/
├── components/character-generation/
│   ├── CharacterGeneratorPanel.vue     # 角色生成面板
│   ├── CharacterPreview.vue            # 角色预览组件
│   ├── PersonalitySelector.vue         # 性格选择器
│   └── QualityAssessmentPanel.vue      # 质量评估面板
├── composables/
│   ├── useCharacterGeneration.ts       # 角色生成逻辑
│   └── useGenerationCache.ts           # 生成缓存管理
└── utils/
    ├── generationCache.ts              # 生成结果缓存
    └── characterValidation.ts          # 角色数据验证
```

### API路由扩展
```typescript
// apps/api/src/routes/character-generation.ts
router.post('/generate/character', async (req, res) => {
  try {
    const { concept, genre, personality, preferences } = req.body

    // 检查缓存
    const cached = await generationCache.get(req.body)
    if (cached) {
      return res.json({ success: true, character: cached, fromCache: true })
    }

    // 生成新角色
    const character = await multimodalAI.generateCompleteCharacter({
      concept,
      genre,
      personality,
      userPreferences: preferences
    })

    // 缓存结果
    await generationCache.set(req.body, character)

    res.json({ success: true, character, fromCache: false })
  } catch (error) {
    res.status(500).json({ success: false, error: error.message })
  }
})

router.post('/generate/avatar', async (req, res) => {
  try {
    const { characterDescription, style, gender, ageRange } = req.body

    const avatar = await multimodalAI.generateCharacterAvatar({
      characterDescription,
      style,
      gender,
      ageRange
    })

    res.json({ success: true, avatar })
  } catch (error) {
    res.status(500).json({ success: false, error: error.message })
  }
})
```

### 环境配置
```typescript
// .env 新增配置
NANO_BANANA_API_KEY=your_nano_banana_api_key
NANO_BANANA_BASE_URL=https://api.nanobanana.dev/v1
CHARACTER_GENERATION_CACHE_SIZE=100
CHARACTER_GENERATION_CACHE_TTL=86400000

# 现有配置保持不变
OPENAI_API_KEY=your_openai_key
ANTHROPIC_API_KEY=your_anthropic_key
# ... 其他现有配置
```

## Definition of Done

### 服务集成检查清单
- [ ] **nano-banana客户端**：正确实现API调用，支持多种图像生成模型
- [ ] **multimodalAI增强**：现有服务功能正确扩展，向后兼容
- [ ] **character-generator完善**：生成逻辑优化，质量显著提升
- [ ] **错误处理完善**：所有AI服务调用都有适当的错误处理和降级策略
- [ ] **API文档更新**：新增的API端点都有完整的文档说明

### 质量保证检查清单
- [ ] **生成质量测试**：100个测试用例生成质量平均分>0.75
- [ ] **性能基准测试**：角色生成时间<30秒，头像生成时间<15秒
- [ ] **并发处理测试**：支持10个并发生成请求不出现性能问题
- [ ] **缓存效果验证**：缓存命中率>60%，缓存读取时间<100ms
- [ ] **资源使用监控**：内存和CPU使用在合理范围内

### 用户验收检查清单
- [ ] **界面交互测试**：所有界面操作流畅，无UI错误
- [ ] **生成结果满意度**：用户测试生成角色满意度>80%
- [ ] **错误恢复能力**：网络错误或服务异常后能正确恢复
- [ ] **移动端适配**：在移动设备上生成流程完整可用
- [ ] **跨浏览器兼容**：在主流浏览器中功能正常

---

*本任务将显著提升TavernAI Plus的角色创建能力，通过AI协作和智能生成，让用户能够轻松创建高质量、个性化的AI角色，降低创作门槛的同时提升创作质量。*