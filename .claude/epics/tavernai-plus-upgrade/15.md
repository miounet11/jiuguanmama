---
name: "动态世界观注入"
status: pending
created: 2025-09-21T02:07:42Z
updated: 2025-09-21T02:36:29Z
github: https://github.com/miounet11/jiuguanbaba/issues/15
depends_on: [13]
parallel: false
conflicts_with: []
estimated_effort: M
estimated_hours: 30
epic: tavernai-plus-upgrade
tags: ["world-building", "context-injection", "storybook-service", "ai-enhancement"]
---

# Task 005: 动态世界观注入

## 概述

基于现有storybookService实现智能关键词触发的世界观卡片系统，通过AI驱动的关键词提取和上下文分析，在对话中自动注入相关的世界观信息。实现沉浸式的角色扮演体验，让用户在对话过程中自然地获取角色背景、世界设定和情境信息。

## 目标

- 基于现有storybookService扩展世界观卡片功能
- 实现AI驱动的关键词自动提取和匹配
- 开发动态世界观信息注入机制
- 建立世界观内容的智能推荐系统
- 优化用户对话中的信息披露体验

## 技术要求

### 核心服务增强

#### 1. storybookService.ts 扩展 - 世界观智能管理
```typescript
// services/storybookService.ts - 扩展现有服务
export class StorybookService {
  private aiKeywordExtractor: AIKeywordExtractor
  private worldInfoCache: Map<string, WorldInfoCard[]>
  private contextAnalyzer: ContextAnalyzer

  /**
   * AI驱动的关键词提取服务
   * 从对话内容中智能提取世界观触发关键词
   */
  async extractKeywordsFromConversation(
    messages: ChatMessage[],
    characterContext: CharacterContext
  ): Promise<ExtractedKeywords> {
    try {
      const conversationText = messages
        .slice(-5) // 分析最近5条消息
        .map(msg => msg.content)
        .join(' ')

      const response = await this.aiService.generateText({
        model: 'grok-3',
        prompt: `
          分析以下对话内容，提取可能需要世界观补充的关键词：

          角色背景：${characterContext.background}
          对话内容：${conversationText}

          请提取：
          1. 地点名称 (places)
          2. 人物关系 (relationships)
          3. 重要物品 (items)
          4. 事件背景 (events)
          5. 专业术语 (terminology)

          返回JSON格式，包含关键词及其重要性评分(1-10)
        `,
        maxTokens: 500,
        temperature: 0.3
      })

      return this.parseKeywordResponse(response.text)
    } catch (error) {
      console.error('关键词提取失败:', error)
      return { keywords: [], confidence: 0 }
    }
  }

  /**
   * 动态生成世界观卡片
   * 基于提取的关键词生成相关的世界观信息
   */
  async generateWorldInfoCards(
    keywords: ExtractedKeywords,
    character: Character,
    conversationContext: ConversationContext
  ): Promise<WorldInfoCard[]> {
    const relevantCards: WorldInfoCard[] = []

    for (const keyword of keywords.keywords) {
      // 检查缓存
      const cached = this.worldInfoCache.get(`${character.id}-${keyword.text}`)
      if (cached) {
        relevantCards.push(...cached)
        continue
      }

      // AI生成新的世界观卡片
      const worldInfo = await this.generateWorldInfoForKeyword(
        keyword,
        character,
        conversationContext
      )

      if (worldInfo) {
        relevantCards.push(worldInfo)
        // 缓存结果
        this.worldInfoCache.set(`${character.id}-${keyword.text}`, [worldInfo])
      }
    }

    return this.rankWorldInfoCards(relevantCards, conversationContext)
  }

  /**
   * 为特定关键词生成世界观信息
   */
  private async generateWorldInfoForKeyword(
    keyword: ExtractedKeyword,
    character: Character,
    context: ConversationContext
  ): Promise<WorldInfoCard | null> {
    try {
      const response = await this.aiService.generateText({
        model: 'grok-3',
        prompt: `
          为角色扮演对话生成世界观信息卡片：

          角色：${character.name} - ${character.description}
          关键词：${keyword.text} (类型：${keyword.type})
          对话情境：${context.currentSituation}

          请生成一个简洁的世界观信息卡片，包含：
          1. 标题 (title)
          2. 描述 (description, 50-100字)
          3. 相关性说明 (relevance, 简短)
          4. 使用建议 (usage_hint)

          要求：
          - 符合角色设定和世界观
          - 能够丰富对话体验
          - 不要过于复杂或冗长
          - 提供实用的背景信息

          返回JSON格式
        `,
        maxTokens: 300,
        temperature: 0.7
      })

      const parsed = JSON.parse(response.text)
      return {
        id: `generated-${Date.now()}-${keyword.text}`,
        keyword: keyword.text,
        title: parsed.title,
        description: parsed.description,
        relevance: parsed.relevance,
        usageHint: parsed.usage_hint,
        type: keyword.type,
        confidence: keyword.confidence,
        generatedAt: new Date(),
        characterId: character.id
      }
    } catch (error) {
      console.error(`生成世界观卡片失败 - ${keyword.text}:`, error)
      return null
    }
  }

  /**
   * 智能排序世界观卡片
   * 基于相关性、对话情境和用户偏好排序
   */
  private rankWorldInfoCards(
    cards: WorldInfoCard[],
    context: ConversationContext
  ): WorldInfoCard[] {
    return cards
      .map(card => ({
        ...card,
        relevanceScore: this.calculateRelevanceScore(card, context)
      }))
      .sort((a, b) => b.relevanceScore - a.relevanceScore)
      .slice(0, 3) // 只保留前3个最相关的卡片
  }

  /**
   * 计算世界观卡片的相关性评分
   */
  private calculateRelevanceScore(
    card: WorldInfoCard,
    context: ConversationContext
  ): number {
    let score = card.confidence || 5

    // 基于对话情境调整评分
    if (context.currentEmotion && card.description.includes(context.currentEmotion)) {
      score += 2
    }

    // 基于最近消息的相关性
    const recentMessages = context.recentMessages.join(' ').toLowerCase()
    if (recentMessages.includes(card.keyword.toLowerCase())) {
      score += 3
    }

    // 基于卡片类型的重要性
    const typeWeights = {
      places: 1.2,
      relationships: 1.5,
      items: 1.0,
      events: 1.3,
      terminology: 0.8
    }
    score *= typeWeights[card.type] || 1.0

    return Math.min(score, 10) // 限制最高分为10
  }
}
```

#### 2. 世界观卡片组件 - WorldInfoCard.vue
```vue
<template>
  <div class="world-info-card" :class="cardTypeClass">
    <!-- 卡片头部 -->
    <div class="card-header">
      <div class="card-icon">
        <component :is="getTypeIcon(card.type)" />
      </div>
      <div class="card-title">
        <h4>{{ card.title }}</h4>
        <span class="card-keyword">{{ card.keyword }}</span>
      </div>
      <div class="card-actions">
        <el-button
          type="text"
          size="small"
          @click="toggleExpanded"
          :icon="expanded ? 'ArrowUp' : 'ArrowDown'"
        />
        <el-button
          type="text"
          size="small"
          @click="useInConversation"
          :icon="'ChatDotRound'"
          title="应用到对话"
        />
      </div>
    </div>

    <!-- 卡片内容 -->
    <div class="card-content" v-show="expanded">
      <p class="card-description">{{ card.description }}</p>

      <!-- 相关性说明 -->
      <div class="card-relevance" v-if="card.relevance">
        <el-icon class="relevance-icon"><InfoFilled /></el-icon>
        <span>{{ card.relevance }}</span>
      </div>

      <!-- 使用建议 -->
      <div class="card-usage-hint" v-if="card.usageHint">
        <el-icon class="hint-icon"><Lightbulb /></el-icon>
        <span>{{ card.usageHint }}</span>
      </div>

      <!-- 操作按钮 -->
      <div class="card-actions-expanded">
        <el-button
          size="small"
          type="primary"
          @click="useInConversation"
        >
          添加到对话
        </el-button>
        <el-button
          size="small"
          @click="saveToLibrary"
        >
          保存到资料库
        </el-button>
        <el-button
          size="small"
          type="info"
          @click="generateMore"
        >
          生成更多
        </el-button>
      </div>
    </div>

    <!-- 置信度指示器 -->
    <div class="confidence-indicator">
      <div
        class="confidence-bar"
        :style="{ width: `${(card.confidence || 5) * 10}%` }"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import type { WorldInfoCard } from '@/types/storybook'

interface Props {
  card: WorldInfoCard
  conversationId: string
}

const props = defineProps<Props>()
const emit = defineEmits<{
  use: [card: WorldInfoCard]
  save: [card: WorldInfoCard]
  generateMore: [keyword: string]
}>()

const expanded = ref(false)

const cardTypeClass = computed(() => `card-type-${props.card.type}`)

const getTypeIcon = (type: string) => {
  const icons = {
    places: 'Location',
    relationships: 'User',
    items: 'Box',
    events: 'Clock',
    terminology: 'Document'
  }
  return icons[type] || 'InfoFilled'
}

const toggleExpanded = () => {
  expanded.value = !expanded.value
}

const useInConversation = () => {
  emit('use', props.card)
}

const saveToLibrary = () => {
  emit('save', props.card)
}

const generateMore = () => {
  emit('generateMore', props.card.keyword)
}
</script>

<style scoped lang="scss">
.world-info-card {
  background: var(--el-bg-color);
  border: 1px solid var(--el-border-color-light);
  border-radius: 8px;
  margin-bottom: 12px;
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;

  &:hover {
    border-color: var(--el-color-primary);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  // 不同类型的卡片颜色
  &.card-type-places {
    border-left: 4px solid #67c23a;
  }
  &.card-type-relationships {
    border-left: 4px solid #409eff;
  }
  &.card-type-items {
    border-left: 4px solid #e6a23c;
  }
  &.card-type-events {
    border-left: 4px solid #f56c6c;
  }
  &.card-type-terminology {
    border-left: 4px solid #909399;
  }

  .card-header {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    cursor: pointer;

    .card-icon {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--el-fill-color-light);
      border-radius: 6px;
      margin-right: 12px;
    }

    .card-title {
      flex: 1;

      h4 {
        margin: 0 0 4px 0;
        font-size: 14px;
        font-weight: 600;
        color: var(--el-text-color-primary);
      }

      .card-keyword {
        font-size: 12px;
        color: var(--el-text-color-secondary);
        background: var(--el-fill-color-lighter);
        padding: 2px 6px;
        border-radius: 4px;
      }
    }

    .card-actions {
      display: flex;
      gap: 4px;
    }
  }

  .card-content {
    padding: 0 16px 16px 16px;

    .card-description {
      font-size: 13px;
      color: var(--el-text-color-regular);
      line-height: 1.5;
      margin: 0 0 12px 0;
    }

    .card-relevance,
    .card-usage-hint {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      font-size: 12px;
      color: var(--el-text-color-secondary);
      margin-bottom: 8px;
      padding: 8px;
      background: var(--el-fill-color-lighter);
      border-radius: 4px;

      .relevance-icon,
      .hint-icon {
        margin-top: 2px;
        flex-shrink: 0;
      }
    }

    .card-actions-expanded {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
  }

  .confidence-indicator {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: var(--el-fill-color-lighter);

    .confidence-bar {
      height: 100%;
      background: linear-gradient(90deg, #f56c6c, #e6a23c, #67c23a);
      transition: width 0.3s ease;
    }
  }
}
</style>
```

#### 3. 动态注入管理器 - DynamicWorldInfoInjector.ts
```typescript
// composables/useDynamicWorldInfo.ts
export function useDynamicWorldInfo(conversationId: string) {
  const worldInfoCards = ref<WorldInfoCard[]>([])
  const isProcessing = ref(false)
  const lastProcessedMessageId = ref<string | null>(null)

  const storybookService = new StorybookService()

  /**
   * 分析新消息并触发世界观注入
   */
  const processNewMessage = async (
    message: ChatMessage,
    character: Character,
    conversationHistory: ChatMessage[]
  ) => {
    if (isProcessing.value || message.id === lastProcessedMessageId.value) {
      return
    }

    try {
      isProcessing.value = true
      lastProcessedMessageId.value = message.id

      // 提取关键词
      const keywords = await storybookService.extractKeywordsFromConversation(
        conversationHistory,
        {
          background: character.description,
          personality: character.personality,
          currentSituation: message.content
        }
      )

      // 生成世界观卡片
      if (keywords.keywords.length > 0) {
        const newCards = await storybookService.generateWorldInfoCards(
          keywords,
          character,
          {
            currentSituation: message.content,
            currentEmotion: extractEmotion(message.content),
            recentMessages: conversationHistory.slice(-3).map(m => m.content)
          }
        )

        // 更新卡片列表，避免重复
        updateWorldInfoCards(newCards)
      }
    } catch (error) {
      console.error('处理动态世界观注入失败:', error)
    } finally {
      isProcessing.value = false
    }
  }

  /**
   * 更新世界观卡片列表
   */
  const updateWorldInfoCards = (newCards: WorldInfoCard[]) => {
    const existingKeywords = new Set(worldInfoCards.value.map(c => c.keyword))

    const uniqueNewCards = newCards.filter(card =>
      !existingKeywords.has(card.keyword)
    )

    worldInfoCards.value = [
      ...uniqueNewCards,
      ...worldInfoCards.value
    ].slice(0, 5) // 只保留最近的5个卡片
  }

  /**
   * 将世界观信息应用到对话
   */
  const applyWorldInfoToConversation = async (card: WorldInfoCard) => {
    try {
      // 构建包含世界观信息的系统提示
      const worldInfoPrompt = `
        [世界观信息]
        ${card.title}: ${card.description}
        ${card.usageHint ? `使用建议: ${card.usageHint}` : ''}

        请在接下来的对话中自然地融入这些背景信息。
      `

      // 发送到AI服务进行对话增强
      await conversationService.injectSystemMessage(conversationId, worldInfoPrompt)

      // 标记卡片已使用
      markCardAsUsed(card.id)

      return true
    } catch (error) {
      console.error('应用世界观信息失败:', error)
      return false
    }
  }

  /**
   * 保存卡片到个人资料库
   */
  const saveCardToLibrary = async (card: WorldInfoCard) => {
    try {
      await storybookService.saveWorldInfoCard({
        ...card,
        userId: userStore.currentUser?.id,
        savedAt: new Date()
      })

      ElMessage.success('已保存到世界观资料库')
      return true
    } catch (error) {
      console.error('保存世界观卡片失败:', error)
      ElMessage.error('保存失败')
      return false
    }
  }

  /**
   * 生成更多相关的世界观信息
   */
  const generateMoreForKeyword = async (keyword: string) => {
    try {
      const moreCards = await storybookService.generateMoreWorldInfoForKeyword(
        keyword,
        conversationId
      )

      updateWorldInfoCards(moreCards)
      return moreCards
    } catch (error) {
      console.error('生成更多世界观信息失败:', error)
      return []
    }
  }

  return {
    worldInfoCards: readonly(worldInfoCards),
    isProcessing: readonly(isProcessing),
    processNewMessage,
    applyWorldInfoToConversation,
    saveCardToLibrary,
    generateMoreForKeyword
  }
}
```

## 验收标准

### 功能验收标准
- [ ] **关键词提取准确性**：AI能从对话中准确提取5类关键词，准确率>80%
- [ ] **世界观卡片生成质量**：生成的卡片内容相关且有用，用户满意度>85%
- [ ] **实时触发机制**：新消息发送后3秒内显示相关世界观卡片
- [ ] **智能排序功能**：世界观卡片按相关性正确排序，最相关的排在前面
- [ ] **一键应用功能**：用户可以一键将世界观信息应用到当前对话

### 性能验收标准
- [ ] **关键词提取速度**：平均响应时间<2秒，包含AI调用
- [ ] **卡片生成效率**：单个世界观卡片生成时间<3秒
- [ ] **缓存命中率**：相同关键词的缓存命中率>60%
- [ ] **内存使用控制**：世界观卡片缓存不超过50MB
- [ ] **并发处理能力**：支持多个对话同时进行世界观注入

### 用户体验验收标准
- [ ] **信息展示清晰**：世界观卡片设计简洁，信息层次分明
- [ ] **交互操作流畅**：展开/收起、应用、保存等操作响应迅速
- [ ] **相关性显示直观**：通过置信度条和颜色编码显示相关性
- [ ] **移动端适配良好**：在手机上卡片显示和操作都正常
- [ ] **错误处理友好**：AI服务失败时有合适的降级处理

### AI质量验收标准
- [ ] **关键词类型准确**：能正确分类地点、人物、物品、事件、术语
- [ ] **世界观内容一致性**：生成的内容与角色设定和已有世界观一致
- [ ] **描述长度适中**：世界观描述控制在50-100字，不冗长不简陋
- [ ] **使用建议实用**：提供的使用建议对对话确实有帮助
- [ ] **多样性保证**：避免生成重复或过于相似的世界观卡片

## 实施细节

### 文件结构
```
apps/web/src/
├── components/storybook/
│   ├── WorldInfoCard.vue                 # 世界观卡片组件
│   ├── WorldInfoPanel.vue               # 世界观面板容器
│   └── KeywordExtractor.vue             # 关键词提取显示
├── composables/
│   ├── useDynamicWorldInfo.ts           # 动态世界观注入逻辑
│   ├── useWorldInfoCache.ts             # 世界观缓存管理
│   └── useKeywordExtraction.ts          # 关键词提取工具
├── services/
│   ├── storybookService.ts              # 扩展现有故事书服务
│   └── worldInfoAI.ts                   # 世界观AI服务
└── types/
    ├── storybook.ts                     # 世界观相关类型定义
    └── worldinfo.ts                     # 世界观卡片类型
```

### API扩展设计
```typescript
// API端点扩展
// POST /api/storybook/extract-keywords
// POST /api/storybook/generate-worldinfo
// POST /api/storybook/save-worldinfo
// GET /api/storybook/worldinfo/:conversationId

interface WorldInfoAPI {
  extractKeywords(conversationId: string, messageIds: string[]): Promise<ExtractedKeywords>
  generateWorldInfo(keywords: ExtractedKeywords, characterId: string): Promise<WorldInfoCard[]>
  saveWorldInfo(card: WorldInfoCard, userId: string): Promise<void>
  getWorldInfoHistory(conversationId: string): Promise<WorldInfoCard[]>
}
```

### 数据库扩展
```sql
-- 世界观卡片表
CREATE TABLE world_info_cards (
  id VARCHAR(255) PRIMARY KEY,
  conversation_id VARCHAR(255),
  character_id VARCHAR(255),
  keyword VARCHAR(100) NOT NULL,
  title VARCHAR(200) NOT NULL,
  description TEXT NOT NULL,
  relevance TEXT,
  usage_hint TEXT,
  type VARCHAR(50) NOT NULL,
  confidence DECIMAL(3,2),
  is_used BOOLEAN DEFAULT FALSE,
  is_saved BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_conversation_keyword (conversation_id, keyword),
  INDEX idx_character_type (character_id, type),
  FOREIGN KEY (conversation_id) REFERENCES conversations(id),
  FOREIGN KEY (character_id) REFERENCES characters(id)
);

-- 关键词提取历史表
CREATE TABLE keyword_extractions (
  id VARCHAR(255) PRIMARY KEY,
  conversation_id VARCHAR(255),
  message_ids JSON,
  extracted_keywords JSON,
  confidence_score DECIMAL(3,2),
  processing_time_ms INT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_conversation_time (conversation_id, created_at),
  FOREIGN KEY (conversation_id) REFERENCES conversations(id)
);
```

### 集成测试方案
```typescript
// tests/integration/worldInfoInjection.test.ts
describe('动态世界观注入系统', () => {
  test('应该从对话中提取正确的关键词', async () => {
    const conversation = await createTestConversation()
    const messages = await addTestMessages(conversation.id, [
      "我们去神秘的翡翠森林探险吧",
      "那里有传说中的精灵女王"
    ])

    const keywords = await storybookService.extractKeywordsFromConversation(
      messages,
      testCharacterContext
    )

    expect(keywords.keywords).toHaveLength(4)
    expect(keywords.keywords.map(k => k.text)).toContain('翡翠森林')
    expect(keywords.keywords.map(k => k.text)).toContain('精灵女王')
  })

  test('应该生成相关的世界观卡片', async () => {
    const keywords = createTestKeywords(['翡翠森林', '精灵女王'])
    const cards = await storybookService.generateWorldInfoCards(
      keywords,
      testCharacter,
      testConversationContext
    )

    expect(cards).toHaveLength(2)
    expect(cards[0].title).toBeTruthy()
    expect(cards[0].description.length).toBeGreaterThan(50)
    expect(cards[0].confidence).toBeGreaterThan(5)
  })

  test('应该正确应用世界观信息到对话', async () => {
    const worldInfoCard = createTestWorldInfoCard()
    const result = await applyWorldInfoToConversation(worldInfoCard)

    expect(result).toBe(true)

    const systemMessages = await getSystemMessages(testConversationId)
    expect(systemMessages).toContainEqual(
      expect.objectContaining({
        content: expect.stringContaining(worldInfoCard.title)
      })
    )
  })
})
```

## Definition of Done

### 代码质量检查清单
- [ ] **TypeScript类型完整**：所有世界观相关类型定义完整，无any类型使用
- [ ] **单元测试覆盖**：核心服务和组件测试覆盖率>85%
- [ ] **集成测试通过**：关键词提取、卡片生成、应用流程的端到端测试
- [ ] **代码审查完成**：AI逻辑和缓存策略通过技术审查
- [ ] **性能测试达标**：关键词提取和卡片生成性能满足要求

### AI质量保证检查清单
- [ ] **提示词工程优化**：关键词提取和世界观生成的提示词经过多轮优化
- [ ] **结果质量验证**：通过50个不同对话场景的质量测试
- [ ] **一致性检查**：生成的世界观信息与角色设定保持一致
- [ ] **多样性验证**：避免生成重复或模板化的内容
- [ ] **错误处理完善**：AI服务异常时的降级策略完整

### 用户体验检查清单
- [ ] **实时性体验良好**：用户在对话中能及时看到相关的世界观提示
- [ ] **信息有用性高**：用户反馈世界观信息确实有助于对话体验
- [ ] **操作简单直观**：用户能轻松理解和使用世界观卡片功能
- [ ] **移动端体验优秀**：手机上的世界观卡片显示和操作流畅
- [ ] **性能影响最小**：功能启用后对对话响应速度影响<10%

### 集成兼容检查清单
- [ ] **与Task003集成**：与简化聊天界面完美配合，不影响对话流畅性
- [ ] **缓存策略合理**：与现有缓存系统协调，避免内存泄漏
- [ ] **API向后兼容**：不破坏现有storybookService的功能
- [ ] **数据库迁移安全**：新增表结构不影响现有数据
- [ ] **错误恢复能力**：服务故障时不影响正常对话功能

### 监控和维护检查清单
- [ ] **关键指标监控**：关键词提取成功率、卡片生成质量、用户使用率
- [ ] **性能监控完整**：AI调用延迟、缓存命中率、内存使用情况
- [ ] **日志记录详细**：便于问题定位和质量改进
- [ ] **A/B测试就绪**：支持不同AI策略的对比测试
- [ ] **运维文档完善**：包含配置说明、故障排查、性能调优指南

---

*本任务是TavernAI Plus智能化体验的重要组成部分，通过AI驱动的世界观注入，将为用户提供更加沉浸式和智能化的角色扮演对话体验。动态世界观系统将显著提升对话的丰富性和连贯性。*