---
name: "移动端体验优化"
status: pending
created: 2025-09-21T02:07:42Z
updated: 2025-09-21T02:36:29Z
github: https://github.com/miounet11/jiuguanbaba/issues/17
depends_on: [11, 13]
parallel: false
conflicts_with: []
estimated_effort: M
estimated_hours: 36
epic: tavernai-plus-upgrade
tags: ["mobile-optimization", "touch-interface", "responsive-design", "pwa"]
---

# Task 007: 移动端体验优化

## 概述

针对触控设备的专门优化，实现原生应用级别的移动端体验。通过手势交互、触控优化、响应式设计完善和PWA增强，确保TavernAI Plus在移动设备上提供与桌面端同等优秀的用户体验，支持离线使用和安装到主屏幕。

## 目标

- 实现触控设备专门的手势交互系统
- 优化移动端的界面布局和组件尺寸
- 完善响应式设计，支持各种屏幕尺寸
- 增强PWA功能，支持离线使用和本地安装
- 优化移动端的性能和加载速度

## 技术要求

### 核心移动端优化组件

#### 1. TouchInterface.vue - 触控交互管理器
```vue
<template>
  <div
    class="touch-interface"
    @touchstart="handleTouchStart"
    @touchmove="handleTouchMove"
    @touchend="handleTouchEnd"
    @touchcancel="handleTouchCancel"
    :class="touchStateClass"
  >
    <!-- 触控反馈元素 -->
    <div
      v-if="showTouchFeedback"
      class="touch-feedback"
      :style="touchFeedbackStyle"
    />

    <!-- 手势提示器 -->
    <div v-if="showGestureHint" class="gesture-hint">
      <div class="hint-content">
        <el-icon class="hint-icon">
          <component :is="gestureHintIcon" />
        </el-icon>
        <span class="hint-text">{{ gestureHintText }}</span>
      </div>
    </div>

    <!-- 内容区域 -->
    <div class="touch-content" ref="contentRef">
      <slot
        :touch-state="touchState"
        :gesture-handlers="gestureHandlers"
        :is-mobile="isMobile"
      />
    </div>

    <!-- 移动端专用工具栏 -->
    <div v-if="isMobile" class="mobile-toolbar">
      <slot name="mobile-toolbar" :actions="mobileActions" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useDeviceDetection } from '@/composables/useDeviceDetection'
import { useTouchGestures } from '@/composables/useTouchGestures'

interface Props {
  enableSwipeGestures?: boolean
  enablePinchZoom?: boolean
  enableLongPress?: boolean
  swipeThreshold?: number
  longPressDelay?: number
  showFeedback?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  enableSwipeGestures: true,
  enablePinchZoom: false,
  enableLongPress: true,
  swipeThreshold: 50,
  longPressDelay: 500,
  showFeedback: true
})

const emit = defineEmits<{
  swipeLeft: []
  swipeRight: []
  swipeUp: []
  swipeDown: []
  longPress: [position: { x: number; y: number }]
  pinchZoom: [scale: number]
  doubleTap: [position: { x: number; y: number }]
}>()

const { isMobile, isTablet, supportsTouch } = useDeviceDetection()
const contentRef = ref<HTMLElement>()

const touchState = ref({
  isPressed: false,
  startPosition: { x: 0, y: 0 },
  currentPosition: { x: 0, y: 0 },
  startTime: 0,
  touchCount: 0
})

const showTouchFeedback = ref(false)
const showGestureHint = ref(false)
const gestureHintText = ref('')
const gestureHintIcon = ref('Touch')

// 触控手势处理器
const {
  handleTouchStart,
  handleTouchMove,
  handleTouchEnd,
  handleTouchCancel,
  gestureHandlers
} = useTouchGestures({
  onSwipeLeft: () => emit('swipeLeft'),
  onSwipeRight: () => emit('swipeRight'),
  onSwipeUp: () => emit('swipeUp'),
  onSwipeDown: () => emit('swipeDown'),
  onLongPress: (pos) => emit('longPress', pos),
  onPinchZoom: (scale) => emit('pinchZoom', scale),
  onDoubleTap: (pos) => emit('doubleTap', pos),
  swipeThreshold: props.swipeThreshold,
  longPressDelay: props.longPressDelay
})

const touchStateClass = computed(() => ({
  'touch-pressed': touchState.value.isPressed,
  'mobile-device': isMobile.value,
  'tablet-device': isTablet.value,
  'supports-touch': supportsTouch.value
}))

const touchFeedbackStyle = computed(() => ({
  left: `${touchState.value.currentPosition.x - 25}px`,
  top: `${touchState.value.currentPosition.y - 25}px`,
  opacity: touchState.value.isPressed ? 0.6 : 0
}))

const mobileActions = computed(() => [
  {
    id: 'back',
    icon: 'ArrowLeft',
    label: '返回',
    action: () => window.history.back()
  },
  {
    id: 'menu',
    icon: 'Menu',
    label: '菜单',
    action: () => showMobileMenu()
  },
  {
    id: 'share',
    icon: 'Share',
    label: '分享',
    action: () => handleMobileShare()
  }
])

/**
 * 显示手势提示
 */
const showGestureGuide = (gesture: string, icon: string, text: string) => {
  gestureHintIcon.value = icon
  gestureHintText.value = text
  showGestureHint.value = true

  setTimeout(() => {
    showGestureHint.value = false
  }, 3000)
}

/**
 * 显示移动端菜单
 */
const showMobileMenu = () => {
  // 触发移动端菜单显示
  document.dispatchEvent(new CustomEvent('show-mobile-menu'))
}

/**
 * 处理移动端分享
 */
const handleMobileShare = async () => {
  if (navigator.share) {
    try {
      await navigator.share({
        title: 'TavernAI Plus',
        text: '体验智能AI角色对话',
        url: window.location.href
      })
    } catch (error) {
      console.log('分享取消或失败:', error)
    }
  } else {
    // 降级处理：复制链接
    await navigator.clipboard.writeText(window.location.href)
    ElMessage.success('链接已复制到剪贴板')
  }
}

// 初始化触控提示
onMounted(() => {
  if (isMobile.value && !localStorage.getItem('mobile-gesture-hint-shown')) {
    setTimeout(() => {
      showGestureGuide(
        'swipe',
        'Pointer',
        '左右滑动切换，长按查看选项'
      )
      localStorage.setItem('mobile-gesture-hint-shown', 'true')
    }, 2000)
  }
})
</script>

<style scoped lang="scss">
.touch-interface {
  position: relative;
  height: 100%;
  overflow: hidden;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;

  &.mobile-device {
    .touch-content {
      padding-bottom: 60px; // 为工具栏留出空间
    }
  }

  .touch-feedback {
    position: fixed;
    width: 50px;
    height: 50px;
    background: rgba(64, 158, 255, 0.3);
    border-radius: 50%;
    pointer-events: none;
    transition: opacity 0.2s ease;
    z-index: 9999;
  }

  .gesture-hint {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 16px 24px;
    border-radius: 12px;
    z-index: 10000;
    animation: fadeInOut 3s ease-in-out;

    .hint-content {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 14px;

      .hint-icon {
        font-size: 20px;
      }
    }
  }

  .mobile-toolbar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 60px;
    background: var(--el-bg-color);
    border-top: 1px solid var(--el-border-color-light);
    display: flex;
    align-items: center;
    justify-content: space-around;
    padding: 0 16px;
    z-index: 1000;

    // 安全区域适配
    padding-bottom: env(safe-area-inset-bottom);
  }
}

@keyframes fadeInOut {
  0%, 100% { opacity: 0; }
  20%, 80% { opacity: 1; }
}
</style>
```

#### 2. MobileCharacterGrid.vue - 移动端角色网格
```vue
<template>
  <div class="mobile-character-grid">
    <!-- 移动端搜索栏 -->
    <div class="mobile-search-header">
      <div class="search-container">
        <el-input
          v-model="searchQuery"
          placeholder="搜索角色..."
          :prefix-icon="Search"
          clearable
          @input="handleSearch"
          size="large"
        />
      </div>
      <el-button
        type="primary"
        :icon="Filter"
        @click="showFilterPanel = true"
        circle
        size="large"
      />
    </div>

    <!-- 快速筛选标签 -->
    <div class="quick-filters" v-if="quickFilters.length">
      <el-scrollbar>
        <div class="filter-tags">
          <el-tag
            v-for="filter in quickFilters"
            :key="filter.id"
            :type="filter.active ? 'primary' : 'info'"
            :effect="filter.active ? 'dark' : 'plain'"
            @click="toggleQuickFilter(filter.id)"
            size="large"
            class="filter-tag"
          >
            {{ filter.label }}
          </el-tag>
        </div>
      </el-scrollbar>
    </div>

    <!-- 移动端角色卡片网格 -->
    <div
      class="character-grid-mobile"
      ref="gridRef"
      @scroll="handleScroll"
    >
      <div
        v-for="character in visibleCharacters"
        :key="character.id"
        class="character-card-mobile"
        @click="handleCharacterSelect(character)"
        @touchstart="handleCardTouchStart(character)"
        @touchend="handleCardTouchEnd"
      >
        <!-- 角色头像 -->
        <div class="card-avatar">
          <img
            :src="character.avatar"
            :alt="character.name"
            @load="handleImageLoad"
            @error="handleImageError"
          />
          <div class="avatar-overlay">
            <el-icon class="chat-icon"><ChatDotRound /></el-icon>
          </div>
        </div>

        <!-- 角色信息 -->
        <div class="card-info">
          <h3 class="character-name">{{ character.name }}</h3>
          <p class="character-description">
            {{ truncateText(character.description, 60) }}
          </p>

          <!-- 标签 -->
          <div class="character-tags">
            <el-tag
              v-for="tag in character.tags.slice(0, 2)"
              :key="tag"
              size="small"
              effect="plain"
            >
              {{ tag }}
            </el-tag>
            <span v-if="character.tags.length > 2" class="more-tags">
              +{{ character.tags.length - 2 }}
            </span>
          </div>

          <!-- 统计信息 -->
          <div class="character-stats">
            <span class="stat-item">
              <el-icon><Star /></el-icon>
              {{ character.rating }}
            </span>
            <span class="stat-item">
              <el-icon><ChatLineRound /></el-icon>
              {{ formatNumber(character.messageCount) }}
            </span>
          </div>
        </div>

        <!-- 快速操作按钮 -->
        <div class="card-actions">
          <el-button
            type="primary"
            size="small"
            @click.stop="startChat(character)"
            :loading="startingChat === character.id"
          >
            开始对话
          </el-button>
        </div>
      </div>

      <!-- 加载更多指示器 -->
      <div v-if="loading" class="loading-indicator">
        <el-skeleton :rows="3" animated />
      </div>

      <!-- 无更多内容 -->
      <div v-if="reachedEnd && !loading" class="end-indicator">
        <el-divider>已显示全部角色</el-divider>
      </div>
    </div>

    <!-- 移动端筛选面板 -->
    <el-drawer
      v-model="showFilterPanel"
      title="筛选角色"
      direction="btt"
      size="70%"
      class="mobile-filter-drawer"
    >
      <MobileFilterPanel
        v-model="activeFilters"
        @apply="applyFilters"
        @reset="resetFilters"
      />
    </el-drawer>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, nextTick } from 'vue'
import { useVirtualList } from '@vueuse/core'
import { useInfiniteScroll } from '@/composables/useInfiniteScroll'
import { useCharacterService } from '@/services/characterService'

interface Props {
  initialCharacters?: Character[]
}

const props = defineProps<Props>()
const emit = defineEmits<{
  characterSelect: [character: Character]
  chatStart: [character: Character]
}>()

const gridRef = ref<HTMLElement>()
const searchQuery = ref('')
const showFilterPanel = ref(false)
const activeFilters = ref({})
const startingChat = ref<string | null>(null)

const characterService = useCharacterService()

// 快速筛选标签
const quickFilters = ref([
  { id: 'popular', label: '热门', active: false },
  { id: 'recent', label: '最新', active: false },
  { id: 'anime', label: '动漫', active: false },
  { id: 'fantasy', label: '奇幻', active: false },
  { id: 'modern', label: '现代', active: false }
])

// 无限滚动
const {
  items: characters,
  loading,
  reachedEnd,
  loadMore
} = useInfiniteScroll({
  fetchData: async (page: number) => {
    return await characterService.getCharacters({
      page,
      limit: 20,
      search: searchQuery.value,
      filters: activeFilters.value
    })
  },
  itemsPerPage: 20
})

// 虚拟化列表优化
const { list: visibleCharacters } = useVirtualList(
  characters,
  {
    itemHeight: 200, // 移动端卡片高度
    overscan: 5
  }
)

/**
 * 处理角色选择
 */
const handleCharacterSelect = (character: Character) => {
  emit('characterSelect', character)
}

/**
 * 开始对话
 */
const startChat = async (character: Character) => {
  startingChat.value = character.id

  try {
    emit('chatStart', character)

    // 触觉反馈
    if (navigator.vibrate) {
      navigator.vibrate(50)
    }
  } finally {
    startingChat.value = null
  }
}

/**
 * 处理卡片触控开始
 */
const handleCardTouchStart = (character: Character) => {
  // 添加触控反馈类
  const cardElement = event.target.closest('.character-card-mobile')
  cardElement?.classList.add('touch-active')
}

/**
 * 处理卡片触控结束
 */
const handleCardTouchEnd = () => {
  // 移除触控反馈类
  setTimeout(() => {
    document.querySelectorAll('.character-card-mobile.touch-active')
      .forEach(el => el.classList.remove('touch-active'))
  }, 150)
}

/**
 * 处理搜索
 */
const handleSearch = useDebounceFn(async (query: string) => {
  searchQuery.value = query
  await loadMore(true) // 重新加载
}, 300)

/**
 * 切换快速筛选
 */
const toggleQuickFilter = (filterId: string) => {
  const filter = quickFilters.value.find(f => f.id === filterId)
  if (filter) {
    filter.active = !filter.active
    updateActiveFilters()
  }
}

/**
 * 更新激活的筛选器
 */
const updateActiveFilters = () => {
  const filters = {}
  quickFilters.value.forEach(filter => {
    if (filter.active) {
      filters[filter.id] = true
    }
  })
  activeFilters.value = filters
  loadMore(true) // 重新加载
}

/**
 * 应用筛选器
 */
const applyFilters = (filters: any) => {
  activeFilters.value = filters
  showFilterPanel.value = false
  loadMore(true)
}

/**
 * 重置筛选器
 */
const resetFilters = () => {
  activeFilters.value = {}
  quickFilters.value.forEach(filter => filter.active = false)
  showFilterPanel.value = false
  loadMore(true)
}

/**
 * 处理滚动
 */
const handleScroll = (event: Event) => {
  const element = event.target as HTMLElement
  const { scrollTop, scrollHeight, clientHeight } = element

  // 接近底部时加载更多
  if (scrollHeight - scrollTop - clientHeight < 200 && !loading.value && !reachedEnd.value) {
    loadMore()
  }
}

/**
 * 格式化数字
 */
const formatNumber = (num: number): string => {
  if (num >= 1000) {
    return (num / 1000).toFixed(1) + 'k'
  }
  return num.toString()
}

/**
 * 截断文本
 */
const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text
  return text.slice(0, maxLength) + '...'
}

/**
 * 处理图片加载
 */
const handleImageLoad = (event: Event) => {
  const img = event.target as HTMLImageElement
  img.classList.add('loaded')
}

/**
 * 处理图片错误
 */
const handleImageError = (event: Event) => {
  const img = event.target as HTMLImageElement
  img.src = '/default-avatar.png'
}

// 初始化
onMounted(() => {
  loadMore()
})
</script>

<style scoped lang="scss">
.mobile-character-grid {
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;

  .mobile-search-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px;
    background: var(--el-bg-color);
    border-bottom: 1px solid var(--el-border-color-lighter);
    // 安全区域适配
    padding-top: calc(16px + env(safe-area-inset-top));

    .search-container {
      flex: 1;
    }
  }

  .quick-filters {
    padding: 12px 16px 8px;
    background: var(--el-bg-color);

    .filter-tags {
      display: flex;
      gap: 8px;
      padding-bottom: 4px;

      .filter-tag {
        flex-shrink: 0;
        cursor: pointer;
        transition: all 0.2s ease;

        &:active {
          transform: scale(0.95);
        }
      }
    }
  }

  .character-grid-mobile {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    -webkit-overflow-scrolling: touch; // iOS 平滑滚动

    .character-card-mobile {
      background: var(--el-bg-color);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      transition: all 0.2s ease;
      cursor: pointer;

      &:active,
      &.touch-active {
        transform: scale(0.98);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
      }

      .card-avatar {
        position: relative;
        width: 80px;
        height: 80px;
        border-radius: 12px;
        overflow: hidden;
        float: left;
        margin-right: 16px;

        img {
          width: 100%;
          height: 100%;
          object-fit: cover;
          opacity: 0;
          transition: opacity 0.3s ease;

          &.loaded {
            opacity: 1;
          }
        }

        .avatar-overlay {
          position: absolute;
          inset: 0;
          background: rgba(0, 0, 0, 0.3);
          display: flex;
          align-items: center;
          justify-content: center;
          opacity: 0;
          transition: opacity 0.2s ease;

          .chat-icon {
            color: white;
            font-size: 24px;
          }
        }

        &:hover .avatar-overlay {
          opacity: 1;
        }
      }

      .card-info {
        overflow: hidden;

        .character-name {
          font-size: 16px;
          font-weight: 600;
          margin: 0 0 8px 0;
          color: var(--el-text-color-primary);
          line-height: 1.3;
        }

        .character-description {
          font-size: 13px;
          color: var(--el-text-color-regular);
          line-height: 1.4;
          margin: 0 0 12px 0;
        }

        .character-tags {
          display: flex;
          align-items: center;
          gap: 6px;
          margin-bottom: 12px;
          flex-wrap: wrap;

          .more-tags {
            font-size: 12px;
            color: var(--el-text-color-secondary);
          }
        }

        .character-stats {
          display: flex;
          align-items: center;
          gap: 16px;
          font-size: 12px;
          color: var(--el-text-color-secondary);

          .stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
          }
        }
      }

      .card-actions {
        clear: both;
        margin-top: 16px;
        display: flex;
        justify-content: flex-end;
      }
    }

    .loading-indicator {
      padding: 20px;
    }

    .end-indicator {
      padding: 20px 0;
      text-align: center;
      color: var(--el-text-color-secondary);
    }
  }
}

// 移动端特定样式
@media (max-width: 768px) {
  .character-card-mobile {
    .card-avatar {
      width: 60px !important;
      height: 60px !important;
    }

    .character-name {
      font-size: 15px !important;
    }

    .character-description {
      font-size: 12px !important;
    }
  }
}

// 超小屏幕适配
@media (max-width: 375px) {
  .mobile-search-header {
    padding: 12px !important;
  }

  .character-grid-mobile {
    padding: 12px !important;

    .character-card-mobile {
      padding: 12px !important;
      margin-bottom: 12px !important;

      .card-avatar {
        margin-right: 12px !important;
      }
    }
  }
}
</style>
```

#### 3. PWA增强服务 - pwaEnhancement.ts
```typescript
// services/pwaEnhancement.ts
export class PWAEnhancementService {
  private deferredPrompt: any = null
  private isInstalled = false
  private offlineCapable = false

  constructor() {
    this.initializePWA()
  }

  /**
   * 初始化PWA功能
   */
  async initializePWA() {
    // 监听安装提示事件
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault()
      this.deferredPrompt = e
      this.showInstallBanner()
    })

    // 监听应用安装完成
    window.addEventListener('appinstalled', () => {
      this.isInstalled = true
      this.hideInstallBanner()
      this.trackEvent('pwa_installed')
    })

    // 检查是否已安装
    this.checkInstallStatus()

    // 注册Service Worker
    await this.registerServiceWorker()

    // 初始化离线功能
    this.initializeOfflineSupport()

    // 初始化缓存策略
    this.initializeCacheStrategy()
  }

  /**
   * 注册Service Worker
   */
  async registerServiceWorker() {
    if ('serviceWorker' in navigator) {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js')

        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                this.showUpdateAvailable()
              }
            })
          }
        })

        console.log('Service Worker注册成功:', registration)
      } catch (error) {
        console.error('Service Worker注册失败:', error)
      }
    }
  }

  /**
   * 检查安装状态
   */
  checkInstallStatus() {
    // 检查是否从主屏幕启动
    if (window.matchMedia('(display-mode: standalone)').matches) {
      this.isInstalled = true
    }

    // 检查是否为PWA环境
    if (window.navigator.standalone === true) {
      this.isInstalled = true
    }
  }

  /**
   * 显示安装横幅
   */
  showInstallBanner() {
    const banner = document.createElement('div')
    banner.className = 'pwa-install-banner'
    banner.innerHTML = `
      <div class="banner-content">
        <div class="banner-text">
          <h4>安装TavernAI Plus</h4>
          <p>获得更好的体验，支持离线使用</p>
        </div>
        <div class="banner-actions">
          <button class="install-btn">安装</button>
          <button class="dismiss-btn">暂不</button>
        </div>
      </div>
    `

    // 添加事件监听
    banner.querySelector('.install-btn')?.addEventListener('click', () => {
      this.promptInstall()
    })

    banner.querySelector('.dismiss-btn')?.addEventListener('click', () => {
      this.hideInstallBanner()
    })

    document.body.appendChild(banner)

    // 添加样式
    this.addInstallBannerStyles()
  }

  /**
   * 提示安装应用
   */
  async promptInstall() {
    if (this.deferredPrompt) {
      this.deferredPrompt.prompt()
      const { outcome } = await this.deferredPrompt.userChoice

      if (outcome === 'accepted') {
        this.trackEvent('pwa_install_accepted')
      } else {
        this.trackEvent('pwa_install_dismissed')
      }

      this.deferredPrompt = null
    }
  }

  /**
   * 隐藏安装横幅
   */
  hideInstallBanner() {
    const banner = document.querySelector('.pwa-install-banner')
    if (banner) {
      banner.remove()
    }
  }

  /**
   * 初始化离线支持
   */
  initializeOfflineSupport() {
    // 监听网络状态变化
    window.addEventListener('online', () => {
      this.showNetworkStatus('已连接到网络', 'success')
      this.syncOfflineData()
    })

    window.addEventListener('offline', () => {
      this.showNetworkStatus('当前离线模式', 'warning')
    })

    // 检查初始网络状态
    if (!navigator.onLine) {
      this.showNetworkStatus('当前离线模式', 'warning')
    }
  }

  /**
   * 显示网络状态
   */
  showNetworkStatus(message: string, type: 'success' | 'warning' | 'error') {
    ElMessage({
      message,
      type,
      duration: 3000,
      showClose: true
    })
  }

  /**
   * 同步离线数据
   */
  async syncOfflineData() {
    try {
      // 同步离线时保存的对话数据
      const offlineChats = await this.getOfflineChats()
      if (offlineChats.length > 0) {
        await this.uploadOfflineChats(offlineChats)
        await this.clearOfflineChats()
        ElMessage.success(`已同步 ${offlineChats.length} 条离线对话`)
      }

      // 同步离线时收藏的角色
      const offlineFavorites = await this.getOfflineFavorites()
      if (offlineFavorites.length > 0) {
        await this.uploadOfflineFavorites(offlineFavorites)
        await this.clearOfflineFavorites()
      }
    } catch (error) {
      console.error('离线数据同步失败:', error)
      ElMessage.error('数据同步失败，将在下次连接时重试')
    }
  }

  /**
   * 初始化缓存策略
   */
  initializeCacheStrategy() {
    // 预缓存关键资源
    this.precacheEssentialResources()

    // 设置角色头像缓存
    this.setupAvatarCaching()

    // 设置API响应缓存
    this.setupAPIResponseCaching()
  }

  /**
   * 预缓存关键资源
   */
  async precacheEssentialResources() {
    const essentialResources = [
      '/',
      '/manifest.json',
      '/offline.html',
      '/assets/default-avatar.png',
      '/assets/logo.png'
    ]

    if ('caches' in window) {
      const cache = await caches.open('tavernai-essential-v1')
      await cache.addAll(essentialResources)
    }
  }

  /**
   * 设置头像缓存
   */
  setupAvatarCaching() {
    // 拦截头像请求并缓存
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data.type === 'CACHE_AVATAR') {
          this.cacheAvatar(event.data.url)
        }
      })
    }
  }

  /**
   * 缓存头像
   */
  async cacheAvatar(url: string) {
    if ('caches' in window) {
      const cache = await caches.open('tavernai-avatars-v1')
      await cache.add(url)
    }
  }

  /**
   * 设置API响应缓存
   */
  setupAPIResponseCaching() {
    // 缓存角色列表和基础数据
    const cacheableEndpoints = [
      '/api/characters',
      '/api/characters/popular',
      '/api/tags',
      '/api/categories'
    ]

    // 通过Service Worker实现智能缓存
    if (navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type: 'SETUP_API_CACHE',
        endpoints: cacheableEndpoints
      })
    }
  }

  /**
   * 显示更新可用提示
   */
  showUpdateAvailable() {
    ElMessageBox.confirm(
      '发现新版本，是否立即更新？',
      '应用更新',
      {
        confirmButtonText: '立即更新',
        cancelButtonText: '稍后提醒',
        type: 'info'
      }
    ).then(() => {
      this.activateUpdate()
    }).catch(() => {
      // 用户选择稍后更新
      setTimeout(() => {
        this.showUpdateAvailable()
      }, 30 * 60 * 1000) // 30分钟后再次提醒
    })
  }

  /**
   * 激活更新
   */
  async activateUpdate() {
    if (navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({ type: 'SKIP_WAITING' })
      window.location.reload()
    }
  }

  /**
   * 获取离线对话
   */
  async getOfflineChats(): Promise<any[]> {
    const db = await this.openIndexedDB()
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['offline_chats'], 'readonly')
      const store = transaction.objectStore('offline_chats')
      const request = store.getAll()

      request.onsuccess = () => resolve(request.result)
      request.onerror = () => reject(request.error)
    })
  }

  /**
   * 打开IndexedDB
   */
  async openIndexedDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('TavernAIOffline', 1)

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result

        if (!db.objectStoreNames.contains('offline_chats')) {
          db.createObjectStore('offline_chats', { keyPath: 'id' })
        }

        if (!db.objectStoreNames.contains('offline_favorites')) {
          db.createObjectStore('offline_favorites', { keyPath: 'id' })
        }
      }

      request.onsuccess = () => resolve(request.result)
      request.onerror = () => reject(request.error)
    })
  }

  /**
   * 添加安装横幅样式
   */
  addInstallBannerStyles() {
    const style = document.createElement('style')
    style.textContent = `
      .pwa-install-banner {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 16px;
        z-index: 10000;
        box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
        animation: slideUp 0.3s ease-out;
      }

      .banner-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
        max-width: 600px;
        margin: 0 auto;
      }

      .banner-text h4 {
        margin: 0 0 4px 0;
        font-size: 16px;
        font-weight: 600;
      }

      .banner-text p {
        margin: 0;
        font-size: 14px;
        opacity: 0.9;
      }

      .banner-actions {
        display: flex;
        gap: 12px;
      }

      .install-btn, .dismiss-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .install-btn {
        background: white;
        color: #667eea;
        font-weight: 600;
      }

      .dismiss-btn {
        background: transparent;
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }

      @keyframes slideUp {
        from { transform: translateY(100%); }
        to { transform: translateY(0); }
      }

      @media (max-width: 768px) {
        .banner-content {
          flex-direction: column;
          gap: 12px;
          text-align: center;
        }
      }
    `
    document.head.appendChild(style)
  }

  /**
   * 事件追踪
   */
  private trackEvent(eventName: string, data?: any) {
    // 发送到分析服务
    if (window.gtag) {
      window.gtag('event', eventName, data)
    }
  }
}
```

## 验收标准

### 移动端体验验收标准
- [ ] **触控交互流畅**：所有手势操作响应迅速，无延迟或卡顿现象
- [ ] **界面适配完美**：在iOS/Android各种屏幕尺寸下显示正常
- [ ] **导航操作直观**：移动端专用导航清晰，单手操作友好
- [ ] **输入体验优秀**：虚拟键盘适配良好，输入框不被遮挡
- [ ] **性能表现优异**：移动端加载速度与桌面端相当

### PWA功能验收标准
- [ ] **离线可用性**：核心功能在离线状态下仍可正常使用
- [ ] **安装流程顺畅**：用户能顺利将应用安装到主屏幕
- [ ] **更新机制完善**：新版本发布后能及时提醒用户更新
- [ ] **缓存策略合理**：常用资源被正确缓存，减少网络请求
- [ ] **数据同步可靠**：离线数据能在网络恢复后正确同步

### 响应式设计验收标准
- [ ] **断点设计合理**：在320px-1920px宽度范围内都能正常显示
- [ ] **组件自适应**：所有组件在不同屏幕下保持合适的尺寸比例
- [ ] **文字清晰可读**：字体大小在移动端足够清晰，行间距合适
- [ ] **图片优化良好**：支持响应式图片，在不同设备下加载合适尺寸
- [ ] **布局灵活稳定**：内容在横竖屏切换时能正确重排

### 性能优化验收标准
- [ ] **首屏加载快速**：移动端首屏渲染时间<2秒
- [ ] **滚动性能良好**：长列表滚动帧率保持在55fps以上
- [ ] **内存使用合理**：长时间使用后内存占用不超过150MB
- [ ] **电池消耗可控**：正常使用不明显增加设备耗电
- [ ] **网络使用优化**：减少不必要的网络请求，支持增量加载

### 可访问性验收标准
- [ ] **触控目标足够大**：按钮和链接的触控区域至少44px×44px
- [ ] **对比度符合标准**：文字与背景对比度满足WCAG AA标准
- [ ] **焦点管理正确**：键盘导航时焦点状态清晰可见
- [ ] **屏幕朗读支持**：重要内容有合适的语义标签
- [ ] **手势替代方案**：所有手势操作都有替代的按钮操作

## 实施细节

### 文件结构
```
apps/web/src/
├── components/mobile/
│   ├── TouchInterface.vue               # 触控交互管理器
│   ├── MobileCharacterGrid.vue          # 移动端角色网格
│   ├── MobileChatInterface.vue          # 移动端聊天界面
│   ├── MobileNavigation.vue             # 移动端导航
│   └── MobileFilterPanel.vue            # 移动端筛选面板
├── composables/
│   ├── useDeviceDetection.ts            # 设备检测
│   ├── useTouchGestures.ts              # 触控手势处理
│   ├── useResponsiveDesign.ts           # 响应式设计工具
│   └── useMobileOptimization.ts         # 移动端优化
├── services/
│   ├── pwaEnhancement.ts                # PWA增强服务
│   └── offlineStorage.ts                # 离线存储服务
├── styles/mobile/
│   ├── touch-interface.scss             # 触控界面样式
│   ├── responsive-grid.scss             # 响应式网格
│   └── mobile-components.scss           # 移动端组件样式
└── public/
    ├── sw.js                            # Service Worker
    ├── manifest.json                    # PWA清单
    └── offline.html                     # 离线页面
```

### Service Worker实现
```javascript
// public/sw.js
const CACHE_NAME = 'tavernai-plus-v1'
const OFFLINE_URL = '/offline.html'

const ESSENTIAL_RESOURCES = [
  '/',
  '/offline.html',
  '/manifest.json',
  '/assets/logo.png',
  '/assets/default-avatar.png'
]

// 安装事件
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(ESSENTIAL_RESOURCES))
      .then(() => self.skipWaiting())
  )
})

// 激活事件
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName)
          }
        })
      )
    }).then(() => self.clients.claim())
  )
})

// 网络请求拦截
self.addEventListener('fetch', (event) => {
  // 只处理同源请求
  if (!event.request.url.startsWith(self.location.origin)) return

  // API请求策略：网络优先，缓存降级
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      fetch(event.request)
        .then((response) => {
          // 缓存成功的API响应
          if (response.ok) {
            const responseClone = response.clone()
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(event.request, responseClone)
            })
          }
          return response
        })
        .catch(() => {
          // 网络失败时返回缓存
          return caches.match(event.request)
        })
    )
    return
  }

  // 静态资源策略：缓存优先
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        if (response) {
          return response
        }

        return fetch(event.request)
          .then((response) => {
            // 缓存新的静态资源
            if (response.ok) {
              const responseClone = response.clone()
              caches.open(CACHE_NAME).then((cache) => {
                cache.put(event.request, responseClone)
              })
            }
            return response
          })
          .catch(() => {
            // 返回离线页面
            if (event.request.mode === 'navigate') {
              return caches.match(OFFLINE_URL)
            }
          })
      })
  )
})

// 消息处理
self.addEventListener('message', (event) => {
  if (event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }

  if (event.data.type === 'CACHE_AVATAR') {
    caches.open('tavernai-avatars-v1').then((cache) => {
      cache.add(event.data.url)
    })
  }
})
```

### PWA清单配置
```json
{
  "name": "TavernAI Plus",
  "short_name": "TavernAI+",
  "description": "智能AI角色扮演对话平台",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#409eff",
  "orientation": "portrait-primary",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "screenshots": [
    {
      "src": "/screenshots/mobile-chat.png",
      "sizes": "390x844",
      "type": "image/png",
      "platform": "mobile",
      "label": "移动端聊天界面"
    },
    {
      "src": "/screenshots/desktop-dashboard.png",
      "sizes": "1280x720",
      "type": "image/png",
      "platform": "wide",
      "label": "桌面端控制台"
    }
  ],
  "categories": ["entertainment", "social", "productivity"],
  "lang": "zh-CN",
  "dir": "ltr"
}
```

### 集成测试方案
```typescript
// tests/mobile/mobileExperience.test.ts
describe('移动端体验测试', () => {
  beforeEach(async () => {
    // 模拟移动设备
    await page.setViewport({ width: 375, height: 667, isMobile: true })
    await page.setUserAgent('Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X)')
  })

  test('移动端角色浏览应该流畅', async () => {
    await page.goto('/characters')

    // 检查移动端布局
    const mobileGrid = await page.$('.mobile-character-grid')
    expect(mobileGrid).toBeTruthy()

    // 测试滚动性能
    await page.evaluate(() => {
      const grid = document.querySelector('.character-grid-mobile')
      grid.scrollTop = 1000
    })

    // 检查无限滚动
    await page.waitForSelector('.loading-indicator', { timeout: 3000 })
    await page.waitForSelector('.character-card-mobile:nth-child(20)', { timeout: 5000 })
  })

  test('触控手势应该正常工作', async () => {
    await page.goto('/chat/test-character')

    // 模拟左滑手势
    await page.touchscreen.swipe(300, 400, 100, 400)

    // 验证手势响应
    const sidePanel = await page.$('.side-panel.open')
    expect(sidePanel).toBeTruthy()

    // 模拟长按手势
    await page.touchscreen.touchStart(200, 300)
    await page.waitForTimeout(600) // 长按时间
    await page.touchscreen.touchEnd()

    // 验证长按菜单
    const contextMenu = await page.$('.context-menu')
    expect(contextMenu).toBeTruthy()
  })

  test('PWA安装流程应该正常', async () => {
    // 模拟PWA安装提示
    await page.evaluate(() => {
      window.dispatchEvent(new Event('beforeinstallprompt'))
    })

    await page.waitForSelector('.pwa-install-banner')

    // 点击安装按钮
    await page.click('.install-btn')

    // 验证安装提示
    const installPrompt = await page.evaluate(() => {
      return window.deferredPrompt !== null
    })
    expect(installPrompt).toBe(true)
  })

  test('离线功能应该可用', async () => {
    // 访问页面并缓存资源
    await page.goto('/')
    await page.waitForLoadState('networkidle')

    // 模拟离线状态
    await page.setOfflineMode(true)

    // 重新加载页面
    await page.reload()

    // 验证离线页面加载
    const offlineContent = await page.textContent('body')
    expect(offlineContent).toContain('离线模式')

    // 验证基础功能可用
    const characterGrid = await page.$('.character-grid')
    expect(characterGrid).toBeTruthy()
  })

  test('响应式设计应该适配各种屏幕', async () => {
    const viewports = [
      { width: 320, height: 568 }, // iPhone 5
      { width: 375, height: 667 }, // iPhone 6/7/8
      { width: 414, height: 896 }, // iPhone 11
      { width: 768, height: 1024 }, // iPad
      { width: 1024, height: 768 }  // iPad横屏
    ]

    for (const viewport of viewports) {
      await page.setViewport(viewport)
      await page.goto('/characters')

      // 检查布局不溢出
      const bodyWidth = await page.evaluate(() => document.body.scrollWidth)
      expect(bodyWidth).toBeLessThanOrEqual(viewport.width)

      // 检查关键元素可见
      const searchBar = await page.$('.mobile-search-header')
      const characterCards = await page.$$('.character-card-mobile')

      expect(searchBar).toBeTruthy()
      expect(characterCards.length).toBeGreaterThan(0)
    }
  })
})
```

## Definition of Done

### 移动端功能检查清单
- [ ] **触控交互完整**：支持点击、长按、滑动、双击、捏合缩放等手势
- [ ] **界面适配完美**：在iOS/Android主流设备上显示和操作正常
- [ ] **性能优化到位**：移动端加载和操作性能与桌面端相当
- [ ] **离线功能可用**：核心功能在无网络状态下仍可使用
- [ ] **PWA功能完整**：支持安装到主屏幕、离线访问、推送通知

### 响应式设计检查清单
- [ ] **断点设计合理**：在320px-1920px宽度范围内都有合适的布局
- [ ] **组件自适应良好**：所有组件在不同屏幕下保持合适比例
- [ ] **文字清晰可读**：在所有设备上字体大小和行间距都合适
- [ ] **图片优化完善**：支持响应式图片和WebP格式
- [ ] **横竖屏适配**：内容在屏幕旋转时能正确重排

### 性能质量检查清单
- [ ] **首屏加载优化**：移动端首屏渲染时间<2秒
- [ ] **滚动性能良好**：长列表滚动保持55fps以上
- [ ] **内存使用合理**：长时间使用内存占用<150MB
- [ ] **网络优化到位**：减少请求数量，支持增量加载
- [ ] **电池消耗可控**：正常使用不明显增加设备耗电

### PWA质量检查清单
- [ ] **Service Worker功能完整**：缓存策略、离线支持、更新机制
- [ ] **清单配置正确**：图标、启动画面、显示模式配置完整
- [ ] **安装体验良好**：安装提示时机恰当，流程顺畅
- [ ] **更新机制完善**：新版本发布后能及时提醒用户
- [ ] **离线数据同步**：网络恢复后能正确同步离线数据

### 可访问性检查清单
- [ ] **触控目标合规**：所有可交互元素触控区域≥44px×44px
- [ ] **对比度达标**：文字与背景对比度满足WCAG AA标准
- [ ] **焦点管理正确**：键盘导航和屏幕朗读支持完善
- [ ] **语义标签完整**：重要内容有合适的ARIA标签
- [ ] **手势替代方案**：所有手势操作都有对应的按钮替代

### 集成兼容检查清单
- [ ] **与前置任务集成**：完美配合角色发现、对话流程等功能
- [ ] **跨平台兼容**：在iOS Safari、Android Chrome等主流浏览器正常
- [ ] **版本兼容性**：支持iOS 12+、Android 8+等主流系统版本
- [ ] **第三方服务兼容**：与AI服务、图片服务等集成正常
- [ ] **数据迁移安全**：现有用户数据在移动端能正确访问

---

*本任务将为TavernAI Plus提供原生应用级别的移动端体验，确保用户在任何设备上都能获得优秀的AI角色扮演对话体验。通过PWA技术，用户可以将应用安装到主屏幕，享受离线使用和原生应用般的流畅体验。*