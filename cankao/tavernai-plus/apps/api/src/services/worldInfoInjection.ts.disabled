import { prisma } from '../server'
import { aiService } from './ai'
import { logger } from './logger'

/**
 * åŠ¨æ€ä¸–ç•Œè§‚æ³¨å…¥æœåŠ¡
 * Issue #15: æ™ºèƒ½å…³é”®è¯è§¦å‘çš„åŠ¨æ€ä¸–ç•Œè§‚æ³¨å…¥ç³»ç»Ÿ
 */

export interface WorldInfoEntry {
  id: string
  bookId: string
  title: string
  content: string
  keywords: string[]
  secondaryKeywords?: string[]
  keywordFilter: 'AND' | 'OR' | 'NOT'
  priority: number
  orderIndex: number
  isEnabled: boolean
  probability: number
  insertionPosition: 'before' | 'after' | 'top' | 'bottom'
  insertionDepth: number
  contextLength: number
  preventRecursion: boolean
  selectiveLogic: string
  constant: boolean
  category: string
  comment?: string
  embedding?: number[]
  relevanceScore?: number
  activationCount: number
  lastActivated?: Date
  createdAt: Date
  updatedAt: Date
}

export interface WorldInfoBook {
  id: string
  name: string
  description?: string
  creatorId: string
  isPublic: boolean
  isGlobal: boolean
  characterIds: string[]
  settings: {
    maxEntries: number
    scanDepth: number
    insertionStrategy: 'before' | 'after' | 'mixed'
    budgetCap: number
    recursiveScanning: boolean
    semanticThreshold: number
    enableAI: boolean
  }
  metadata: any
  createdAt: Date
  updatedAt: Date
}

export interface ConversationContext {
  sessionId?: string
  roomId?: string
  userId: string
  characterId?: string
  messages: Array<{
    role: 'system' | 'user' | 'assistant'
    content: string
    timestamp?: Date
  }>
  currentMessage: string
  metadata?: any
}

export interface InjectionResult {
  activatedEntries: WorldInfoEntry[]
  injectedContent: string
  relevanceScores: Record<string, number>
  triggeredKeywords: Record<string, string[]>
  totalTokens: number
  performance: {
    analysisTime: number
    injectionTime: number
    totalTime: number
  }
}

export interface KeywordAnalysisResult {
  detectedKeywords: string[]
  entities: Array<{
    text: string
    type: 'PERSON' | 'LOCATION' | 'ORGANIZATION' | 'EVENT' | 'ITEM' | 'CONCEPT'
    confidence: number
  }>
  sentiment: {
    score: number // -1 to 1
    magnitude: number
    emotion: string
  }
  context: {
    theme: string
    topics: string[]
    relevantConcepts: string[]
  }
}

class WorldInfoInjectionService {
  private cache = new Map<string, any>()
  private readonly CACHE_TTL = 5 * 60 * 1000 // 5 minutes

  /**
   * ä¸»è¦å…¥å£ï¼šåˆ†æå¯¹è¯å¹¶åŠ¨æ€æ³¨å…¥ä¸–ç•Œè§‚ä¿¡æ¯
   */
  async analyzeAndInjectWorldInfo(context: ConversationContext): Promise<InjectionResult> {
    const startTime = Date.now()

    try {
      // 1. æ™ºèƒ½å…³é”®è¯è¯†åˆ«å’Œä¸Šä¸‹æ–‡åˆ†æ
      const analysisStart = Date.now()
      const keywordAnalysis = await this.analyzeConversationContext(context)
      const analysisTime = Date.now() - analysisStart

      // 2. è·å–ç›¸å…³ä¸–ç•Œè§‚ä¹¦ç±
      const relevantBooks = await this.getRelevantWorldInfoBooks(context)

      // 3. æ‰«æå¹¶æ¿€æ´»ç›¸å…³æ¡ç›®
      const injectionStart = Date.now()
      const activatedEntries = await this.scanAndActivateEntries(
        relevantBooks,
        context,
        keywordAnalysis
      )

      // 4. ç”Ÿæˆæ³¨å…¥å†…å®¹
      const injectedContent = await this.generateInjectionContent(
        activatedEntries,
        context,
        keywordAnalysis
      )

      // 5. è®°å½•æ¿€æ´»æ—¥å¿—
      await this.logActivations(activatedEntries, context, keywordAnalysis)

      const injectionTime = Date.now() - injectionStart
      const totalTime = Date.now() - startTime

      return {
        activatedEntries,
        injectedContent,
        relevanceScores: this.calculateRelevanceScores(activatedEntries, keywordAnalysis),
        triggeredKeywords: this.extractTriggeredKeywords(activatedEntries, keywordAnalysis),
        totalTokens: this.estimateTokens(injectedContent),
        performance: {
          analysisTime,
          injectionTime,
          totalTime
        }
      }
    } catch (error) {
      logger.error('WorldInfo injection failed', { error, context })
      throw new Error(`ä¸–ç•Œè§‚æ³¨å…¥å¤±è´¥: ${error.message}`)
    }
  }

  /**
   * AIé©±åŠ¨çš„ä¸Šä¸‹æ–‡å…³é”®è¯æ£€æµ‹å’Œåˆ†æ
   */
  async analyzeConversationContext(context: ConversationContext): Promise<KeywordAnalysisResult> {
    const cacheKey = `analysis:${this.hashContext(context)}`

    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey)
      if (Date.now() - cached.timestamp < this.CACHE_TTL) {
        return cached.data
      }
    }

    try {
      // æ„å»ºåˆ†ææ¶ˆæ¯å†å²
      const recentMessages = context.messages.slice(-5).map(m => m.content).join('\n')
      const fullContext = `${recentMessages}\nå½“å‰æ¶ˆæ¯: ${context.currentMessage}`

      // AIåˆ†ææç¤ºè¯
      const analysisPrompt = `è¯·åˆ†æä»¥ä¸‹å¯¹è¯å†…å®¹ï¼Œæå–å…³é”®ä¿¡æ¯ï¼š

å¯¹è¯å†…å®¹ï¼š
${fullContext}

è¯·åˆ†æå¹¶è¿”å›JSONæ ¼å¼ç»“æœï¼ŒåŒ…å«ï¼š
1. detectedKeywords: æ£€æµ‹åˆ°çš„å…³é”®è¯åˆ—è¡¨
2. entities: å®ä½“è¯†åˆ«ç»“æœï¼ˆäººç‰©ã€åœ°ç‚¹ã€ç»„ç»‡ã€äº‹ä»¶ã€ç‰©å“ã€æ¦‚å¿µï¼‰
3. sentiment: æƒ…æ„Ÿåˆ†æï¼ˆåˆ†æ•°ã€å¼ºåº¦ã€æƒ…ç»ªï¼‰
4. context: ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼ˆä¸»é¢˜ã€è¯é¢˜ã€ç›¸å…³æ¦‚å¿µï¼‰

ç¤ºä¾‹æ ¼å¼ï¼š
{
  "detectedKeywords": ["é­”æ³•", "å­¦é™¢", "æ³•å¸ˆ"],
  "entities": [
    {"text": "éœæ ¼æ²ƒèŒ¨", "type": "LOCATION", "confidence": 0.9}
  ],
  "sentiment": {
    "score": 0.2,
    "magnitude": 0.5,
    "emotion": "å¥½å¥‡"
  },
  "context": {
    "theme": "é­”æ³•æ•™è‚²",
    "topics": ["é­”æ³•å­¦ä¹ ", "å­¦é™¢ç”Ÿæ´»"],
    "relevantConcepts": ["é­”æ³•ç³»ç»Ÿ", "å­¦æ ¡è§„åˆ™"]
  }
}`

      // è°ƒç”¨AIåˆ†æ
      const response = await aiService.generateChatResponse({
        model: 'grok-3',
        messages: [
          {
            role: 'system',
            content: 'ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ–‡æœ¬åˆ†æAIï¼Œæ“…é•¿æå–å…³é”®è¯ã€å®ä½“è¯†åˆ«å’Œä¸Šä¸‹æ–‡åˆ†æã€‚è¯·ç›´æ¥è¿”å›JSONæ ¼å¼ç»“æœã€‚'
          },
          {
            role: 'user',
            content: analysisPrompt
          }
        ],
        temperature: 0.3,
        maxTokens: 1000
      })

      let analysisResult: KeywordAnalysisResult
      try {
        analysisResult = JSON.parse(response.content)
      } catch (parseError) {
        // é™çº§å¤„ç†ï¼šåŸºäºè§„åˆ™çš„å…³é”®è¯æå–
        logger.warn('AI analysis parsing failed, using fallback', { parseError })
        analysisResult = this.fallbackKeywordAnalysis(fullContext)
      }

      // ç¼“å­˜ç»“æœ
      this.cache.set(cacheKey, {
        data: analysisResult,
        timestamp: Date.now()
      })

      return analysisResult
    } catch (error) {
      logger.error('Context analysis failed', { error })
      // é™çº§å¤„ç†
      return this.fallbackKeywordAnalysis(context.currentMessage)
    }
  }

  /**
   * è·å–ç›¸å…³çš„ä¸–ç•Œè§‚ä¹¦ç±
   */
  private async getRelevantWorldInfoBooks(context: ConversationContext): Promise<WorldInfoBook[]> {
    try {
      // æ„å»ºæŸ¥è¯¢æ¡ä»¶
      const whereConditions: any = {
        OR: [
          { isGlobal: true },
          { isPublic: true }
        ]
      }

      // å¦‚æœæœ‰è§’è‰²IDï¼ŒåŒ…å«è§’è‰²ç‰¹å®šçš„ä¸–ç•Œè§‚
      if (context.characterId) {
        whereConditions.OR.push({
          characterIds: {
            contains: context.characterId
          }
        })
      }

      // æŸ¥è¯¢æ•°æ®åº“ï¼ˆæ¨¡æ‹ŸæŸ¥è¯¢ï¼Œå®é™…éœ€è¦å®ç°æ•°æ®åº“è¡¨ï¼‰
      // const books = await prisma.worldInfoBook.findMany({
      //   where: whereConditions,
      //   include: {
      //     entries: {
      //       where: { isEnabled: true },
      //       orderBy: { priority: 'desc' }
      //     }
      //   }
      // })

      // ä¸´æ—¶è¿”å›æ¨¡æ‹Ÿæ•°æ®
      return this.getMockWorldInfoBooks(context)
    } catch (error) {
      logger.error('Failed to get WorldInfo books', { error })
      return []
    }
  }

  /**
   * æ‰«æå¹¶æ¿€æ´»ç›¸å…³æ¡ç›®
   */
  private async scanAndActivateEntries(
    books: WorldInfoBook[],
    context: ConversationContext,
    analysis: KeywordAnalysisResult
  ): Promise<WorldInfoEntry[]> {
    const activatedEntries: WorldInfoEntry[] = []
    const scanText = `${context.messages.slice(-3).map(m => m.content).join(' ')} ${context.currentMessage}`

    for (const book of books) {
      const entries = await this.getBookEntries(book.id)

      for (const entry of entries) {
        if (!entry.isEnabled) continue

        // 1. å…³é”®è¯åŒ¹é…æ£€æŸ¥
        const keywordMatches = this.checkKeywordMatches(entry, scanText, analysis)

        // 2. è¯­ä¹‰ç›¸ä¼¼åº¦æ£€æŸ¥ï¼ˆå¦‚æœå¯ç”¨AIåˆ†æï¼‰
        const semanticScore = book.settings.enableAI
          ? await this.calculateSemanticSimilarity(entry, scanText)
          : 0

        // 3. ä¸Šä¸‹æ–‡ç›¸å…³æ€§æ£€æŸ¥
        const contextRelevance = this.calculateContextRelevance(entry, analysis)

        // 4. æ¦‚ç‡æ£€æŸ¥
        const shouldActivate = this.shouldActivateEntry(
          entry,
          keywordMatches,
          semanticScore,
          contextRelevance,
          book.settings
        )

        if (shouldActivate) {
          // æ›´æ–°ç›¸å…³æ€§åˆ†æ•°
          entry.relevanceScore = Math.max(
            keywordMatches.score,
            semanticScore,
            contextRelevance
          )
          activatedEntries.push(entry)
        }
      }
    }

    // æŒ‰ä¼˜å…ˆçº§å’Œç›¸å…³æ€§æ’åº
    activatedEntries.sort((a, b) => {
      const priorityDiff = b.priority - a.priority
      if (priorityDiff !== 0) return priorityDiff
      return (b.relevanceScore || 0) - (a.relevanceScore || 0)
    })

    // é™åˆ¶æœ€å¤§æ¡ç›®æ•°
    const maxEntries = books.reduce((max, book) => Math.max(max, book.settings.maxEntries), 10)
    return activatedEntries.slice(0, maxEntries)
  }

  /**
   * æ£€æŸ¥å…³é”®è¯åŒ¹é…
   */
  private checkKeywordMatches(
    entry: WorldInfoEntry,
    text: string,
    analysis: KeywordAnalysisResult
  ): { matches: boolean; score: number; keywords: string[] } {
    const textLower = text.toLowerCase()
    const detectedKeywords = analysis.detectedKeywords.map(k => k.toLowerCase())

    const primaryMatches = entry.keywords.filter(keyword =>
      textLower.includes(keyword.toLowerCase()) ||
      detectedKeywords.includes(keyword.toLowerCase())
    )

    const secondaryMatches = (entry.secondaryKeywords || []).filter(keyword =>
      textLower.includes(keyword.toLowerCase()) ||
      detectedKeywords.includes(keyword.toLowerCase())
    )

    let matches = false
    let score = 0

    switch (entry.keywordFilter) {
      case 'AND':
        matches = entry.keywords.every(keyword =>
          textLower.includes(keyword.toLowerCase()) ||
          detectedKeywords.includes(keyword.toLowerCase())
        )
        score = matches ? 1.0 : 0
        break

      case 'OR':
        matches = primaryMatches.length > 0 || secondaryMatches.length > 0
        score = (primaryMatches.length * 1.0 + secondaryMatches.length * 0.5) /
                Math.max(entry.keywords.length + (entry.secondaryKeywords?.length || 0), 1)
        break

      case 'NOT':
        matches = primaryMatches.length === 0
        score = matches ? 1.0 : 0
        break
    }

    return {
      matches,
      score: Math.min(score, 1.0),
      keywords: [...primaryMatches, ...secondaryMatches]
    }
  }

  /**
   * è®¡ç®—è¯­ä¹‰ç›¸ä¼¼åº¦ï¼ˆä½¿ç”¨AIï¼‰
   */
  private async calculateSemanticSimilarity(entry: WorldInfoEntry, text: string): Promise<number> {
    try {
      // å¦‚æœæœ‰é¢„è®¡ç®—çš„å‘é‡åµŒå…¥ï¼Œä½¿ç”¨å‘é‡ç›¸ä¼¼åº¦
      if (entry.embedding) {
        // TODO: å®ç°å‘é‡ç›¸ä¼¼åº¦è®¡ç®—
        return 0.5
      }

      // ä½¿ç”¨AIåˆ¤æ–­è¯­ä¹‰ç›¸ä¼¼åº¦
      const prompt = `è¯·åˆ¤æ–­ä»¥ä¸‹ä¸¤ä¸ªæ–‡æœ¬çš„è¯­ä¹‰ç›¸å…³æ€§ï¼ˆ0-1åˆ†ï¼‰ï¼š

æ–‡æœ¬1ï¼ˆä¸–ç•Œè§‚æ¡ç›®ï¼‰ï¼š
æ ‡é¢˜ï¼š${entry.title}
å†…å®¹ï¼š${entry.content}

æ–‡æœ¬2ï¼ˆå¯¹è¯å†…å®¹ï¼‰ï¼š
${text}

è¯·åªè¿”å›ä¸€ä¸ª0åˆ°1ä¹‹é—´çš„æ•°å­—ï¼Œè¡¨ç¤ºç›¸å…³æ€§åˆ†æ•°ã€‚`

      const response = await aiService.generateChatResponse({
        model: 'grok-3',
        messages: [
          {
            role: 'system',
            content: 'ä½ æ˜¯è¯­ä¹‰ç›¸ä¼¼åº¦åˆ†æä¸“å®¶ã€‚è¯·åˆ†æä¸¤ä¸ªæ–‡æœ¬çš„è¯­ä¹‰ç›¸å…³æ€§ï¼Œè¿”å›0-1ä¹‹é—´çš„åˆ†æ•°ã€‚åªè¿”å›æ•°å­—ã€‚'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1,
        maxTokens: 10
      })

      const score = parseFloat(response.content.trim())
      return isNaN(score) ? 0 : Math.max(0, Math.min(1, score))
    } catch (error) {
      logger.error('Semantic similarity calculation failed', { error })
      return 0
    }
  }

  /**
   * è®¡ç®—ä¸Šä¸‹æ–‡ç›¸å…³æ€§
   */
  private calculateContextRelevance(entry: WorldInfoEntry, analysis: KeywordAnalysisResult): number {
    let relevance = 0

    // ä¸»é¢˜åŒ¹é…
    if (analysis.context.theme && entry.content.toLowerCase().includes(analysis.context.theme.toLowerCase())) {
      relevance += 0.3
    }

    // è¯é¢˜åŒ¹é…
    const topicMatches = analysis.context.topics.filter(topic =>
      entry.content.toLowerCase().includes(topic.toLowerCase()) ||
      entry.title.toLowerCase().includes(topic.toLowerCase())
    )
    relevance += (topicMatches.length / Math.max(analysis.context.topics.length, 1)) * 0.4

    // æ¦‚å¿µåŒ¹é…
    const conceptMatches = analysis.context.relevantConcepts.filter(concept =>
      entry.content.toLowerCase().includes(concept.toLowerCase()) ||
      entry.keywords.some(keyword => keyword.toLowerCase().includes(concept.toLowerCase()))
    )
    relevance += (conceptMatches.length / Math.max(analysis.context.relevantConcepts.length, 1)) * 0.3

    return Math.min(relevance, 1.0)
  }

  /**
   * åˆ¤æ–­æ˜¯å¦åº”è¯¥æ¿€æ´»æ¡ç›®
   */
  private shouldActivateEntry(
    entry: WorldInfoEntry,
    keywordMatches: { matches: boolean; score: number; keywords: string[] },
    semanticScore: number,
    contextRelevance: number,
    settings: WorldInfoBook['settings']
  ): boolean {
    // å¸¸é‡æ¡ç›®å§‹ç»ˆæ¿€æ´»
    if (entry.constant) return true

    // æ£€æŸ¥æœ€ä½è¯­ä¹‰é˜ˆå€¼
    const maxScore = Math.max(keywordMatches.score, semanticScore, contextRelevance)
    if (maxScore < settings.semanticThreshold) return false

    // å…³é”®è¯åŒ¹é…æˆ–è¯­ä¹‰ç›¸ä¼¼åº¦è¶³å¤Ÿé«˜
    if (!keywordMatches.matches && semanticScore < 0.5 && contextRelevance < 0.5) {
      return false
    }

    // æ¦‚ç‡æ£€æŸ¥
    const activationProbability = entry.probability / 100
    return Math.random() < activationProbability
  }

  /**
   * ç”Ÿæˆæ³¨å…¥å†…å®¹
   */
  private async generateInjectionContent(
    entries: WorldInfoEntry[],
    context: ConversationContext,
    analysis: KeywordAnalysisResult
  ): Promise<string> {
    if (entries.length === 0) return ''

    // æŒ‰ç±»åˆ«åˆ†ç»„
    const groupedEntries = this.groupEntriesByCategory(entries)

    let injectedContent = ''
    const categoryNames: Record<string, string> = {
      location: 'ğŸ“ åœ°ç‚¹ä¿¡æ¯',
      character: 'ğŸ‘¤ äººç‰©èƒŒæ™¯',
      item: 'ğŸ’ ç‰©å“è¯´æ˜',
      lore: 'ğŸ“œ ä¼ è¯´çŸ¥è¯†',
      event: 'âš¡ äº‹ä»¶èƒŒæ™¯',
      general: 'ğŸ’¡ ç›¸å…³ä¿¡æ¯',
      custom: 'ğŸ”– è¡¥å……å†…å®¹'
    }

    // æ™ºèƒ½æ ¼å¼åŒ–æ³¨å…¥å†…å®¹
    for (const [category, categoryEntries] of Object.entries(groupedEntries)) {
      if (categoryEntries.length === 0) continue

      injectedContent += `\nã€${categoryNames[category] || category}ã€‘\n`

      for (const entry of categoryEntries) {
        // æ ¹æ®ç›¸å…³æ€§è°ƒæ•´å†…å®¹é•¿åº¦
        const relevance = entry.relevanceScore || 0
        let content = entry.content

        // é«˜ç›¸å…³æ€§æ˜¾ç¤ºå®Œæ•´å†…å®¹ï¼Œä½ç›¸å…³æ€§æ˜¾ç¤ºæ‘˜è¦
        if (relevance < 0.7 && content.length > entry.contextLength) {
          content = await this.generateContentSummary(content, analysis, entry.contextLength)
        }

        injectedContent += `â€¢ ${entry.title}: ${content}\n`
      }
    }

    return injectedContent.trim()
  }

  /**
   * ç”Ÿæˆå†…å®¹æ‘˜è¦
   */
  private async generateContentSummary(
    content: string,
    analysis: KeywordAnalysisResult,
    maxLength: number
  ): Promise<string> {
    if (content.length <= maxLength) return content

    try {
      const prompt = `è¯·å°†ä»¥ä¸‹å†…å®¹å‹ç¼©ä¸ºä¸è¶…è¿‡${maxLength}å­—ç¬¦çš„æ‘˜è¦ï¼Œä¿ç•™ä¸"${analysis.detectedKeywords.join('ã€')}"ç›¸å…³çš„å…³é”®ä¿¡æ¯ï¼š

${content}

æ‘˜è¦ï¼š`

      const response = await aiService.generateChatResponse({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: 'ä½ æ˜¯å†…å®¹æ‘˜è¦ä¸“å®¶ï¼Œæ“…é•¿æå–å…³é”®ä¿¡æ¯å¹¶ä¿æŒåŸæ„ã€‚'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        maxTokens: Math.ceil(maxLength / 2)
      })

      return response.content.trim() || content.substring(0, maxLength) + '...'
    } catch (error) {
      logger.error('Content summary generation failed', { error })
      return content.substring(0, maxLength) + '...'
    }
  }

  /**
   * è®°å½•æ¿€æ´»æ—¥å¿—
   */
  private async logActivations(
    entries: WorldInfoEntry[],
    context: ConversationContext,
    analysis: KeywordAnalysisResult
  ): Promise<void> {
    try {
      for (const entry of entries) {
        // TODO: å®ç°æ•°æ®åº“æ—¥å¿—è®°å½•
        // await prisma.worldInfoActivation.create({
        //   data: {
        //     entryId: entry.id,
        //     sessionId: context.sessionId,
        //     userId: context.userId,
        //     characterId: context.characterId,
        //     roomId: context.roomId,
        //     triggeredBy: 'ai_analysis',
        //     keywords: JSON.stringify(analysis.detectedKeywords),
        //     relevanceScore: entry.relevanceScore || 0,
        //     contextText: context.currentMessage,
        //     injectionPosition: entry.insertionPosition,
        //     metadata: JSON.stringify({
        //       analysis,
        //       performance: Date.now()
        //     })
        //   }
        // })

        // æ›´æ–°æ¡ç›®æ¿€æ´»ç»Ÿè®¡
        entry.activationCount++
        entry.lastActivated = new Date()
      }
    } catch (error) {
      logger.error('Failed to log activations', { error })
    }
  }

  /**
   * è¾…åŠ©æ–¹æ³•
   */
  private hashContext(context: ConversationContext): string {
    const key = `${context.userId}-${context.characterId}-${context.currentMessage.substring(0, 50)}`
    return Buffer.from(key).toString('base64').substring(0, 32)
  }

  private fallbackKeywordAnalysis(text: string): KeywordAnalysisResult {
    // ç®€å•çš„åŸºäºè§„åˆ™çš„å…³é”®è¯æå–
    const commonKeywords = ['é­”æ³•', 'å­¦é™¢', 'å†’é™©', 'æˆ˜æ–—', 'å‹è°Š', 'çˆ±æƒ…', 'å®¶æ—', 'ç‹å›½', 'æ³•å¸ˆ', 'éª‘å£«']
    const detectedKeywords = commonKeywords.filter(keyword =>
      text.toLowerCase().includes(keyword)
    )

    return {
      detectedKeywords,
      entities: [],
      sentiment: {
        score: 0,
        magnitude: 0.5,
        emotion: 'ä¸­æ€§'
      },
      context: {
        theme: 'å¯¹è¯',
        topics: detectedKeywords,
        relevantConcepts: detectedKeywords
      }
    }
  }

  private calculateRelevanceScores(entries: WorldInfoEntry[], analysis: KeywordAnalysisResult): Record<string, number> {
    const scores: Record<string, number> = {}
    entries.forEach(entry => {
      scores[entry.id] = entry.relevanceScore || 0
    })
    return scores
  }

  private extractTriggeredKeywords(entries: WorldInfoEntry[], analysis: KeywordAnalysisResult): Record<string, string[]> {
    const triggered: Record<string, string[]> = {}
    entries.forEach(entry => {
      triggered[entry.id] = entry.keywords.filter(keyword =>
        analysis.detectedKeywords.some(detected =>
          detected.toLowerCase().includes(keyword.toLowerCase())
        )
      )
    })
    return triggered
  }

  private estimateTokens(text: string): number {
    // ç®€å•çš„tokenä¼°ç®—ï¼šä¸­æ–‡å­—ç¬¦/1.5 + è‹±æ–‡å­—ç¬¦/4
    const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length
    const englishChars = text.length - chineseChars
    return Math.ceil(chineseChars / 1.5 + englishChars / 4)
  }

  private groupEntriesByCategory(entries: WorldInfoEntry[]): Record<string, WorldInfoEntry[]> {
    const grouped: Record<string, WorldInfoEntry[]> = {}
    entries.forEach(entry => {
      const category = entry.category || 'general'
      if (!grouped[category]) grouped[category] = []
      grouped[category].push(entry)
    })
    return grouped
  }

  private async getBookEntries(bookId: string): Promise<WorldInfoEntry[]> {
    // TODO: å®ç°æ•°æ®åº“æŸ¥è¯¢
    // return await prisma.worldInfoEntry.findMany({
    //   where: { bookId, isEnabled: true },
    //   orderBy: { priority: 'desc' }
    // })

    // ä¸´æ—¶è¿”å›æ¨¡æ‹Ÿæ•°æ®
    return this.getMockWorldInfoEntries()
  }

  /**
   * æ¨¡æ‹Ÿæ•°æ®æ–¹æ³•ï¼ˆå¼€å‘æµ‹è¯•ç”¨ï¼‰
   */
  private getMockWorldInfoBooks(context: ConversationContext): WorldInfoBook[] {
    return [
      {
        id: 'book_fantasy_world',
        name: 'å¹»æƒ³ä¸–ç•Œè®¾å®šé›†',
        description: 'åŒ…å«é­”æ³•ç³»ç»Ÿã€ç§æ—è®¾å®šã€åœ°ç†ä¿¡æ¯ç­‰',
        creatorId: 'system',
        isPublic: true,
        isGlobal: true,
        characterIds: [],
        settings: {
          maxEntries: 10,
          scanDepth: 5,
          insertionStrategy: 'before',
          budgetCap: 2000,
          recursiveScanning: true,
          semanticThreshold: 0.3,
          enableAI: true
        },
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ]
  }

  private getMockWorldInfoEntries(): WorldInfoEntry[] {
    return [
      {
        id: 'entry_magic_system',
        bookId: 'book_fantasy_world',
        title: 'é­”æ³•ç³»ç»Ÿ',
        content: 'è¿™ä¸ªä¸–ç•Œçš„é­”æ³•åˆ†ä¸ºå…ƒç´ é­”æ³•ã€ç¥åœ£é­”æ³•å’Œç¦å¿Œé­”æ³•ä¸‰å¤§ç±»ã€‚å…ƒç´ é­”æ³•åŒ…æ‹¬ç«ã€æ°´ã€åœŸã€é£å››ç§åŸºæœ¬å…ƒç´ ï¼Œæ¯ä¸ªæ³•å¸ˆé€šå¸¸åªèƒ½æŒæ¡ä¸€åˆ°ä¸¤ç§å…ƒç´ ã€‚',
        keywords: ['é­”æ³•', 'æ³•æœ¯', 'å…ƒç´ ', 'ç«é­”æ³•', 'æ°´é­”æ³•', 'åœŸé­”æ³•', 'é£é­”æ³•'],
        secondaryKeywords: ['å’’è¯­', 'æ³•å¸ˆ', 'é­”åŠ›'],
        keywordFilter: 'OR',
        priority: 100,
        orderIndex: 1,
        isEnabled: true,
        probability: 80,
        insertionPosition: 'before',
        insertionDepth: 3,
        contextLength: 300,
        preventRecursion: true,
        selectiveLogic: '',
        constant: false,
        category: 'lore',
        comment: 'æ ¸å¿ƒé­”æ³•ç³»ç»Ÿè®¾å®š',
        relevanceScore: 0,
        activationCount: 0,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: 'entry_magic_academy',
        bookId: 'book_fantasy_world',
        title: 'é­”æ³•å­¦é™¢',
        content: 'ä½äºè‰¾å°”ç™»å¤§é™†ä¸­å¿ƒçš„å¤è€é­”æ³•å­¦é™¢ï¼Œæ˜¯å¤§é™†ä¸Šæœ€æƒå¨çš„é­”æ³•æ•™è‚²æœºæ„ã€‚å­¦é™¢åˆ†ä¸ºå››ä¸ªå­¦é™¢ï¼šç‚ç«å­¦é™¢ã€ç¢§æ°´å­¦é™¢ã€åšåœŸå­¦é™¢å’Œç–¾é£å­¦é™¢ã€‚',
        keywords: ['å­¦é™¢', 'é­”æ³•å­¦é™¢', 'è‰¾å°”ç™»', 'ç‚ç«å­¦é™¢', 'ç¢§æ°´å­¦é™¢', 'åšåœŸå­¦é™¢', 'ç–¾é£å­¦é™¢'],
        secondaryKeywords: ['å­¦æ ¡', 'æ•™è‚²', 'å­¦ä¹ '],
        keywordFilter: 'OR',
        priority: 90,
        orderIndex: 2,
        isEnabled: true,
        probability: 70,
        insertionPosition: 'before',
        insertionDepth: 3,
        contextLength: 250,
        preventRecursion: true,
        selectiveLogic: '',
        constant: false,
        category: 'location',
        comment: 'é­”æ³•å­¦é™¢è®¾å®š',
        relevanceScore: 0,
        activationCount: 0,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: 'entry_legendary_sword',
        bookId: 'book_fantasy_world',
        title: 'ä¼ è¯´åœ£å‰‘',
        content: 'æµå…‰åœ£å‰‘ï¼Œä¼ è¯´ä¸­çš„ç¥å™¨ä¹‹ä¸€ã€‚å‰‘èº«ç”±æ˜Ÿè¾°é™¨é“é”»é€ ï¼Œå‰‘æŸ„é•¶åµŒç€å¤è€çš„é­”æ³•æ°´æ™¶ã€‚åªæœ‰çœŸæ­£çš„å‹‡è€…æ‰èƒ½æŒ¥èˆè¿™æŠŠåœ£å‰‘ã€‚',
        keywords: ['åœ£å‰‘', 'æµå…‰åœ£å‰‘', 'ç¥å™¨', 'ä¼ è¯´', 'å‹‡è€…'],
        secondaryKeywords: ['æ­¦å™¨', 'å‰‘', 'ä¼ è¯´æ­¦å™¨'],
        keywordFilter: 'OR',
        priority: 80,
        orderIndex: 3,
        isEnabled: true,
        probability: 60,
        insertionPosition: 'before',
        insertionDepth: 3,
        contextLength: 200,
        preventRecursion: true,
        selectiveLogic: '',
        constant: false,
        category: 'item',
        comment: 'ä¼ è¯´æ­¦å™¨è®¾å®š',
        relevanceScore: 0,
        activationCount: 0,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ]
  }
}

export const worldInfoInjectionService = new WorldInfoInjectionService()
export default worldInfoInjectionService