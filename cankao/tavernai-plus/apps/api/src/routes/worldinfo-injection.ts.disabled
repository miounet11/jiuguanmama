import { Router } from 'express'
import { authenticate, AuthRequest } from '../middleware/auth'
import { validate } from '../middleware/validate'
import { worldInfoInjectionService } from '../services/worldInfoInjection'
import multimodalAI from '../services/multimodalAI'
import { logger } from '../services/logger'
import { z } from 'zod'

const router = Router()

/**
 * 动态世界观注入API路由
 * Issue #15: 智能关键词触发的动态世界观注入系统
 */

// 验证schema
const analyzeContextSchema = z.object({
  sessionId: z.string().optional(),
  roomId: z.string().optional(),
  characterId: z.string().optional(),
  messages: z.array(z.object({
    role: z.enum(['system', 'user', 'assistant']),
    content: z.string(),
    timestamp: z.string().datetime().optional()
  })),
  currentMessage: z.string(),
  settings: z.object({
    maxEntries: z.number().min(1).max(50).default(10),
    scanDepth: z.number().min(1).max(20).default(5),
    semanticThreshold: z.number().min(0).max(1).default(0.3),
    enableAI: z.boolean().default(true),
    insertionStrategy: z.enum(['before', 'after', 'mixed']).default('before')
  }).optional()
})

const keywordExtractionSchema = z.object({
  text: z.string().min(1).max(5000),
  language: z.string().default('zh-CN'),
  maxKeywords: z.number().min(1).max(30).default(15),
  entityTypes: z.array(z.enum(['PERSON', 'LOCATION', 'ORGANIZATION', 'EVENT', 'ITEM', 'CONCEPT'])).optional()
})

const worldInfoSummarySchema = z.object({
  content: z.string().min(1),
  context: z.object({
    keywords: z.array(z.string()),
    themes: z.array(z.string()),
    maxLength: z.number().min(50).max(1000).default(300)
  }),
  preserveStyle: z.boolean().default(false)
})

const emotionalAnalysisSchema = z.object({
  messages: z.array(z.object({
    role: z.string(),
    content: z.string()
  })),
  characterId: z.string().optional(),
  includeAdvice: z.boolean().default(true)
})

const voiceOptimizationSchema = z.object({
  content: z.string().min(1),
  character: z.object({
    name: z.string(),
    personality: z.string().optional(),
    speakingStyle: z.string().optional()
  }),
  tone: z.enum(['formal', 'casual', 'mysterious', 'friendly']).default('friendly'),
  length: z.enum(['brief', 'normal', 'detailed']).default('normal')
})

/**
 * 分析对话上下文并动态注入世界观信息
 * POST /api/worldinfo/analyze
 */
router.post('/analyze', authenticate, validate(analyzeContextSchema), async (req: AuthRequest, res, next) => {
  try {
    const { sessionId, roomId, characterId, messages, currentMessage, settings } = req.body
    const userId = req.user!.id

    logger.info('WorldInfo analysis started', {
      userId,
      sessionId,
      roomId,
      characterId,
      messageLength: currentMessage.length,
      historyLength: messages.length
    })

    // 构建对话上下文
    const context = {
      sessionId,
      roomId,
      userId,
      characterId,
      messages: messages.map((m: any) => ({
        role: m.role,
        content: m.content,
        timestamp: m.timestamp ? new Date(m.timestamp) : new Date()
      })),
      currentMessage,
      metadata: { settings }
    }

    // 执行分析和注入
    const startTime = Date.now()
    const injectionResult = await worldInfoInjectionService.analyzeAndInjectWorldInfo(context)
    const processingTime = Date.now() - startTime

    logger.info('WorldInfo analysis completed', {
      userId,
      sessionId,
      activatedEntries: injectionResult.activatedEntries.length,
      totalTokens: injectionResult.totalTokens,
      processingTime,
      performance: injectionResult.performance
    })

    res.json({
      success: true,
      data: {
        injectedContent: injectionResult.injectedContent,
        activatedEntries: injectionResult.activatedEntries.map(entry => ({
          id: entry.id,
          title: entry.title,
          category: entry.category,
          priority: entry.priority,
          relevanceScore: entry.relevanceScore,
          insertionPosition: entry.insertionPosition
        })),
        relevanceScores: injectionResult.relevanceScores,
        triggeredKeywords: injectionResult.triggeredKeywords,
        totalTokens: injectionResult.totalTokens,
        performance: injectionResult.performance,
        suggestions: {
          appropriateForInjection: true,
          suggestedTiming: 'immediate',
          confidence: Math.max(...Object.values(injectionResult.relevanceScores))
        }
      },
      meta: {
        processingTime,
        timestamp: new Date().toISOString()
      }
    })
  } catch (error) {
    logger.error('WorldInfo analysis failed', { error, userId: req.user!.id })
    next(error)
  }
})

/**
 * AI驱动的关键词提取和实体识别
 * POST /api/worldinfo/extract-keywords
 */
router.post('/extract-keywords', authenticate, validate(keywordExtractionSchema), async (req: AuthRequest, res, next) => {
  try {
    const { text, language, maxKeywords, entityTypes } = req.body
    const userId = req.user!.id

    logger.info('Keyword extraction started', { userId, textLength: text.length })

    const result = await multimodalAI.extractKeywordsAI(text, {
      userId,
      language,
      maxKeywords,
      entityTypes
    })

    res.json({
      success: true,
      data: result,
      meta: {
        textLength: text.length,
        keywordCount: result.keywords.length,
        entityCount: result.entities.length,
        timestamp: new Date().toISOString()
      }
    })
  } catch (error) {
    logger.error('Keyword extraction failed', { error, userId: req.user!.id })
    next(error)
  }
})

/**
 * 智能世界观信息摘要生成
 * POST /api/worldinfo/generate-summary
 */
router.post('/generate-summary', authenticate, validate(worldInfoSummarySchema), async (req: AuthRequest, res, next) => {
  try {
    const { content, context, preserveStyle } = req.body
    const userId = req.user!.id

    logger.info('WorldInfo summary generation started', {
      userId,
      contentLength: content.length,
      maxLength: context.maxLength
    })

    const result = await multimodalAI.generateWorldInfoSummary(content, context, {
      userId,
      preserveStyle
    })

    res.json({
      success: true,
      data: result,
      meta: {
        originalLength: content.length,
        summaryLength: result.summary.length,
        compressionRatio: result.summary.length / content.length,
        timestamp: new Date().toISOString()
      }
    })
  } catch (error) {
    logger.error('WorldInfo summary generation failed', { error, userId: req.user!.id })
    next(error)
  }
})

/**
 * 对话情感上下文分析
 * POST /api/worldinfo/analyze-emotion
 */
router.post('/analyze-emotion', authenticate, validate(emotionalAnalysisSchema), async (req: AuthRequest, res, next) => {
  try {
    const { messages, characterId, includeAdvice } = req.body
    const userId = req.user!.id

    logger.info('Emotional context analysis started', {
      userId,
      characterId,
      messageCount: messages.length
    })

    const result = await multimodalAI.detectEmotionalContext(messages, {
      userId,
      characterId,
      includeAdvice
    })

    res.json({
      success: true,
      data: result,
      meta: {
        messageCount: messages.length,
        timestamp: new Date().toISOString()
      }
    })
  } catch (error) {
    logger.error('Emotional context analysis failed', { error, userId: req.user!.id })
    next(error)
  }
})

/**
 * 角色语音风格优化
 * POST /api/worldinfo/optimize-voice
 */
router.post('/optimize-voice', authenticate, validate(voiceOptimizationSchema), async (req: AuthRequest, res, next) => {
  try {
    const { content, character, tone, length } = req.body
    const userId = req.user!.id

    logger.info('Voice optimization started', {
      userId,
      characterName: character.name,
      contentLength: content.length,
      tone,
      length
    })

    const result = await multimodalAI.optimizeForCharacterVoice(content, character, {
      userId,
      tone,
      length
    })

    res.json({
      success: true,
      data: result,
      meta: {
        originalLength: content.length,
        optimizedLength: result.optimizedContent.length,
        voiceMatching: result.voiceMatching,
        timestamp: new Date().toISOString()
      }
    })
  } catch (error) {
    logger.error('Voice optimization failed', { error, userId: req.user!.id })
    next(error)
  }
})

/**
 * 获取世界观注入建议
 * GET /api/worldinfo/suggestions
 */
router.get('/suggestions', authenticate, async (req: AuthRequest, res, next) => {
  try {
    const { sessionId, characterId, context } = req.query
    const userId = req.user!.id

    // 基于用户历史和偏好提供智能建议
    const suggestions = {
      recommendedBooks: [
        {
          id: 'book_fantasy_world',
          name: '幻想世界设定集',
          relevance: 0.85,
          entryCount: 15,
          categories: ['location', 'lore', 'item']
        }
      ],
      keywordTriggers: [
        '魔法', '学院', '冒险', '传说', '武器'
      ],
      injectionStrategies: [
        {
          strategy: 'contextual',
          description: '基于对话上下文智能注入',
          confidence: 0.9
        },
        {
          strategy: 'character_driven',
          description: '根据角色特征触发相关信息',
          confidence: 0.75
        }
      ],
      settings: {
        recommended: {
          maxEntries: 8,
          scanDepth: 5,
          semanticThreshold: 0.4,
          enableAI: true,
          insertionStrategy: 'before'
        },
        performance: {
          averageLatency: '180ms',
          successRate: '94%',
          userSatisfaction: 4.2
        }
      }
    }

    res.json({
      success: true,
      data: suggestions,
      meta: {
        userId,
        sessionId,
        characterId,
        timestamp: new Date().toISOString()
      }
    })
  } catch (error) {
    logger.error('Failed to get WorldInfo suggestions', { error, userId: req.user!.id })
    next(error)
  }
})

/**
 * 获取世界观注入统计信息
 * GET /api/worldinfo/stats
 */
router.get('/stats', authenticate, async (req: AuthRequest, res, next) => {
  try {
    const { timeRange = '7d' } = req.query
    const userId = req.user!.id

    // 计算时间范围
    const now = new Date()
    const timeRanges = {
      '1d': new Date(now.getTime() - 24 * 60 * 60 * 1000),
      '7d': new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000),
      '30d': new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
    }

    const startDate = timeRanges[timeRange as keyof typeof timeRanges] || timeRanges['7d']

    // 模拟统计数据（实际应从数据库查询）
    const stats = {
      totalActivations: 142,
      uniqueEntries: 28,
      averageRelevance: 0.73,
      successfulInjections: 134,
      failedInjections: 8,
      topCategories: [
        { category: 'location', count: 45, percentage: 31.7 },
        { category: 'lore', count: 38, percentage: 26.8 },
        { category: 'character', count: 32, percentage: 22.5 },
        { category: 'item', count: 27, percentage: 19.0 }
      ],
      topKeywords: [
        { keyword: '魔法', activations: 23, relevance: 0.89 },
        { keyword: '学院', activations: 19, relevance: 0.82 },
        { keyword: '冒险', activations: 16, relevance: 0.77 },
        { keyword: '传说', activations: 14, relevance: 0.85 }
      ],
      performance: {
        averageLatency: 185,
        p95Latency: 340,
        p99Latency: 580,
        aiAnalysisTime: 120,
        injectionTime: 45
      },
      userFeedback: {
        helpful: 89,
        neutral: 8,
        unhelpful: 3,
        averageRating: 4.1
      }
    }

    res.json({
      success: true,
      data: stats,
      meta: {
        userId,
        timeRange,
        startDate: startDate.toISOString(),
        endDate: now.toISOString(),
        timestamp: new Date().toISOString()
      }
    })
  } catch (error) {
    logger.error('Failed to get WorldInfo stats', { error, userId: req.user!.id })
    next(error)
  }
})

/**
 * 用户反馈接口
 * POST /api/worldinfo/feedback
 */
router.post('/feedback', authenticate, async (req: AuthRequest, res, next) => {
  try {
    const { entryId, injectionId, feedback, rating, comment } = req.body
    const userId = req.user!.id

    // 验证反馈数据
    if (!entryId || !feedback || !['helpful', 'neutral', 'unhelpful'].includes(feedback)) {
      return res.status(400).json({
        success: false,
        message: '无效的反馈数据'
      })
    }

    // TODO: 保存反馈到数据库
    // await prisma.worldInfoFeedback.create({
    //   data: {
    //     userId,
    //     entryId,
    //     injectionId,
    //     feedback,
    //     rating: rating ? Math.max(1, Math.min(5, rating)) : null,
    //     comment,
    //     createdAt: new Date()
    //   }
    // })

    logger.info('WorldInfo feedback received', {
      userId,
      entryId,
      feedback,
      rating
    })

    res.json({
      success: true,
      message: '反馈已收到，感谢您的意见',
      data: {
        processed: true,
        timestamp: new Date().toISOString()
      }
    })
  } catch (error) {
    logger.error('Failed to process WorldInfo feedback', { error, userId: req.user!.id })
    next(error)
  }
})

/**
 * 实时关键词监控（WebSocket支持的HTTP端点）
 * POST /api/worldinfo/monitor-keywords
 */
router.post('/monitor-keywords', authenticate, async (req: AuthRequest, res, next) => {
  try {
    const { sessionId, roomId, keywords, threshold = 0.5 } = req.body
    const userId = req.user!.id

    // 设置关键词监控
    const monitorConfig = {
      sessionId,
      roomId,
      userId,
      keywords: Array.isArray(keywords) ? keywords : [keywords],
      threshold,
      active: true,
      createdAt: new Date()
    }

    // TODO: 保存监控配置到Redis或内存存储
    // await redis.setex(`worldinfo:monitor:${sessionId}`, 3600, JSON.stringify(monitorConfig))

    logger.info('WorldInfo keyword monitoring activated', {
      userId,
      sessionId,
      roomId,
      keywordCount: monitorConfig.keywords.length
    })

    res.json({
      success: true,
      data: {
        monitorId: `monitor_${sessionId}_${Date.now()}`,
        config: monitorConfig,
        message: '关键词监控已激活'
      },
      meta: {
        timestamp: new Date().toISOString()
      }
    })
  } catch (error) {
    logger.error('Failed to activate keyword monitoring', { error, userId: req.user!.id })
    next(error)
  }
})

export default router