# TavernAI Plus 技术架构详细设计

## 一、架构设计原则

### 1.1 核心原则
- **模块化设计** - 基于 SillyTavern 进行模块化改造
- **微服务架构** - 服务解耦，独立部署和扩展
- **高可用性** - 多节点部署，故障自动切换
- **可扩展性** - 水平扩展，支持高并发
- **安全性** - 多层防护，数据加密

### 1.2 技术栈对比

| 层级 | SillyTavern 原有 | TavernAI Plus 升级 |
|-----|-----------------|-------------------|
| 前端 | Vanilla JS + jQuery | Vue 3 + TypeScript + Vite |
| 后端 | Express.js | Express + NestJS 混合 |
| 数据库 | 文件系统 | PostgreSQL + MongoDB + Redis |
| 认证 | 基础认证 | JWT + OAuth2 + RBAC |
| 部署 | 单机部署 | Docker + K8s + 云原生 |

## 二、系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                         客户端层                              │
├─────────────────────────────────────────────────────────────┤
│   Web App    │   iOS App    │  Android App  │  Desktop App  │
│   (Vue3)     │   (Swift)    │   (Kotlin)   │  (Electron)   │
└──────┬───────────────┬──────────────┬────────────┬──────────┘
       │               │              │            │
       └───────────────┴──────────────┴────────────┘
                              │
                    ┌─────────▼──────────┐
                    │   CDN + 负载均衡    │
                    │  (CloudFlare/AWS)   │
                    └─────────┬──────────┘
                              │
                    ┌─────────▼──────────┐
                    │    API Gateway     │
                    │   (Kong/Nginx)     │
                    └─────────┬──────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────▼────────┐  ┌────────▼────────┐  ┌────────▼────────┐
│   认证服务      │  │   业务服务集群   │  │    AI 服务集群   │
│  Auth Service   │  │ Business Cluster│  │   AI Cluster    │
├────────────────┤  ├─────────────────┤  ├─────────────────┤
│ • 用户注册登录  │  │ • 角色管理       │  │ • 模型路由       │
│ • JWT 管理     │  │ • 聊天服务       │  │ • 提示词优化     │
│ • 权限控制     │  │ • 故事管理       │  │ • 流式输出       │
│ • OAuth2      │  │ • 市场服务       │  │ • 上下文管理     │
└────────┬───────┘  └────────┬────────┘  └────────┬────────┘
         │                   │                     │
         └───────────────────┼─────────────────────┘
                             │
                 ┌───────────┼───────────┐
                 │           │           │
         ┌───────▼──┐  ┌────▼────┐  ┌──▼──────┐
         │PostgreSQL│  │ MongoDB │  │  Redis  │
         │  主数据库 │  │ 文档存储 │  │  缓存   │
         └──────────┘  └─────────┘  └─────────┘
                             │
                    ┌────────▼────────┐
                    │   对象存储(S3)   │
                    │  MinIO/AWS S3    │
                    └─────────────────┘
```

## 三、核心模块设计

### 3.1 基于 SillyTavern 的改造方案

#### A. 保留模块（优化升级）
```javascript
// 保留并优化的 SillyTavern 模块
const preservedModules = {
  // AI 提供商集成 - 保留核心逻辑
  'src/endpoints/backends/': {
    status: 'optimize',
    changes: [
      '添加 TypeScript 类型定义',
      '优化错误处理机制',
      '添加重试逻辑',
      '统一响应格式'
    ]
  },
  
  // 扩展系统 - 保留架构
  'public/scripts/extensions/': {
    status: 'enhance',
    changes: [
      '迁移到 Vue 组件',
      '添加扩展市场',
      '权限控制',
      '版本管理'
    ]
  },
  
  // 向量存储 - 保留并扩展
  'src/vectors/': {
    status: 'extend',
    changes: [
      '添加更多向量数据库支持',
      '优化索引策略',
      '批量处理能力'
    ]
  }
};
```

#### B. 新增模块
```typescript
// 新增的核心服务模块
interface CoreServices {
  // 用户服务
  UserService: {
    authentication: AuthenticationModule;
    authorization: AuthorizationModule;
    profile: ProfileModule;
    subscription: SubscriptionModule;
  };
  
  // 角色服务
  CharacterService: {
    creation: CharacterCreationModule;
    management: CharacterManagementModule;
    marketplace: MarketplaceModule;
    generation: AIGenerationModule;
  };
  
  // 聊天服务
  ChatService: {
    session: SessionManagementModule;
    message: MessageProcessingModule;
    streaming: StreamingModule;
    context: ContextManagementModule;
  };
  
  // 支付服务
  PaymentService: {
    subscription: SubscriptionPaymentModule;
    credits: CreditSystemModule;
    billing: BillingModule;
  };
}
```

### 3.2 数据库设计

#### A. PostgreSQL 主数据库
```sql
-- 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255),
    avatar_url VARCHAR(500),
    bio TEXT,
    credits INTEGER DEFAULT 100,
    subscription_tier VARCHAR(20) DEFAULT 'free',
    subscription_expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP,
    is_active BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- 角色表
CREATE TABLE characters (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    personality TEXT,
    first_message TEXT,
    avatar_url VARCHAR(500),
    cover_image_url VARCHAR(500),
    tags TEXT[],
    is_public BOOLEAN DEFAULT false,
    is_nsfw BOOLEAN DEFAULT false,
    rating DECIMAL(3,2) DEFAULT 0,
    rating_count INTEGER DEFAULT 0,
    chat_count INTEGER DEFAULT 0,
    favorite_count INTEGER DEFAULT 0,
    version INTEGER DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metadata JSONB DEFAULT '{}'::jsonb,
    INDEX idx_characters_user_id (user_id),
    INDEX idx_characters_public (is_public),
    INDEX idx_characters_rating (rating DESC)
);

-- 聊天会话表
CREATE TABLE chat_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200),
    character_ids UUID[],
    model VARCHAR(50) DEFAULT 'gpt-3.5-turbo',
    preset_id UUID,
    world_info_id UUID,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_message_at TIMESTAMP,
    message_count INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    is_archived BOOLEAN DEFAULT false,
    metadata JSONB DEFAULT '{}'::jsonb,
    INDEX idx_sessions_user_id (user_id),
    INDEX idx_sessions_updated (updated_at DESC)
);

-- 订阅计划表
CREATE TABLE subscription_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL,
    tier VARCHAR(20) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'USD',
    duration_days INTEGER NOT NULL,
    features JSONB NOT NULL,
    limits JSONB NOT NULL,
    is_active BOOLEAN DEFAULT true
);

-- 交易记录表
CREATE TABLE transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    type VARCHAR(20) NOT NULL, -- subscription, credits, refund
    amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'USD',
    status VARCHAR(20) DEFAULT 'pending',
    payment_method VARCHAR(50),
    payment_id VARCHAR(255),
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    metadata JSONB DEFAULT '{}'::jsonb,
    INDEX idx_transactions_user_id (user_id),
    INDEX idx_transactions_status (status)
);
```

#### B. MongoDB 文档存储
```javascript
// 聊天消息集合
const MessageSchema = {
  _id: ObjectId,
  session_id: String,      // UUID from PostgreSQL
  user_id: String,         // UUID from PostgreSQL
  character_id: String,    // UUID from PostgreSQL
  role: String,            // user, assistant, system
  content: String,
  tokens: Number,
  timestamp: Date,
  edited: Boolean,
  deleted: Boolean,
  metadata: {
    model: String,
    temperature: Number,
    max_tokens: Number,
    guidance: String,
    emotions: Array
  }
};

// 世界观/知识库集合
const WorldInfoSchema = {
  _id: ObjectId,
  user_id: String,
  name: String,
  description: String,
  entries: [{
    id: String,
    keys: [String],       // 触发关键词
    content: String,      // 条目内容
    priority: Number,
    enabled: Boolean,
    position: String,     // before, after
    depth: Number,
    case_sensitive: Boolean
  }],
  created_at: Date,
  updated_at: Date,
  is_public: Boolean,
  tags: [String]
};

// 故事书集合
const StoryBookSchema = {
  _id: ObjectId,
  user_id: String,
  title: String,
  description: String,
  chapters: [{
    id: String,
    title: String,
    content: String,
    trigger_condition: String,
    order: Number,
    is_active: Boolean
  }],
  characters: [String],    // Character IDs
  world_info_id: String,
  created_at: Date,
  updated_at: Date,
  is_public: Boolean
};
```

#### C. Redis 缓存设计
```javascript
// Redis 键设计规范
const redisKeys = {
  // 用户会话
  session: 'session:{user_id}',
  
  // 用户在线状态
  online: 'online:{user_id}',
  
  // 聊天会话缓存
  chatSession: 'chat:session:{session_id}',
  
  // 角色缓存
  character: 'character:{character_id}',
  
  // 热门角色列表
  hotCharacters: 'hot:characters',
  
  // API 限流
  rateLimit: 'rate:{user_id}:{endpoint}',
  
  // 模型配额
  quota: 'quota:{user_id}:{model}',
  
  // 实时消息队列
  messageQueue: 'queue:messages:{session_id}',
  
  // 缓存过期时间
  ttl: {
    session: 86400,        // 24小时
    character: 3600,       // 1小时
    hotCharacters: 300,    // 5分钟
    rateLimit: 60,        // 1分钟
    messageQueue: 1800    // 30分钟
  }
};
```

### 3.3 API 设计

#### A. RESTful API 规范
```yaml
# OpenAPI 3.0 规范示例
openapi: 3.0.0
info:
  title: TavernAI Plus API
  version: 1.0.0
  description: AI 角色扮演平台 API

servers:
  - url: https://api.tavernai.com/v1
    description: Production server
  - url: https://staging-api.tavernai.com/v1
    description: Staging server

paths:
  /auth/register:
    post:
      summary: 用户注册
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                username:
                  type: string
                  minLength: 3
                  maxLength: 30
                email:
                  type: string
                  format: email
                password:
                  type: string
                  minLength: 8
              required:
                - username
                - email
                - password
      responses:
        201:
          description: 注册成功
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        400:
          $ref: '#/components/responses/BadRequest'
        409:
          $ref: '#/components/responses/Conflict'

  /characters:
    get:
      summary: 获取角色列表
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
        - name: sort
          in: query
          schema:
            type: string
            enum: [rating, created, popular]
        - name: tags
          in: query
          schema:
            type: array
            items:
              type: string
      responses:
        200:
          description: 成功
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/Character'
                  pagination:
                    $ref: '#/components/schemas/Pagination'

  /chat/sessions/{sessionId}/messages:
    post:
      summary: 发送聊天消息
      parameters:
        - name: sessionId
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                content:
                  type: string
                character_id:
                  type: string
                  format: uuid
                guidance:
                  type: string
                stream:
                  type: boolean
                  default: true
      responses:
        200:
          description: 成功
          content:
            text/event-stream:
              schema:
                type: string
                description: SSE 流式响应
```

#### B. WebSocket 实时通信
```typescript
// WebSocket 事件设计
interface WebSocketEvents {
  // 客户端 -> 服务器
  client: {
    'auth': { token: string };
    'join_session': { session_id: string };
    'leave_session': { session_id: string };
    'send_message': {
      session_id: string;
      content: string;
      character_id?: string;
    };
    'typing': { session_id: string; is_typing: boolean };
    'summon_character': {
      session_id: string;
      character_id: string;
    };
  };
  
  // 服务器 -> 客户端
  server: {
    'auth_success': { user_id: string };
    'auth_error': { message: string };
    'message': {
      session_id: string;
      message: Message;
      is_streaming?: boolean;
    };
    'message_chunk': {
      session_id: string;
      chunk: string;
      message_id: string;
    };
    'user_typing': {
      session_id: string;
      user_id: string;
      is_typing: boolean;
    };
    'character_summoned': {
      session_id: string;
      character: Character;
    };
    'error': {
      code: string;
      message: string;
    };
  };
}

// WebSocket 服务器实现
class WebSocketServer {
  constructor(server: http.Server) {
    this.io = new Server(server, {
      cors: {
        origin: process.env.CLIENT_URL,
        credentials: true
      },
      adapter: createAdapter(redisClient)
    });
    
    this.setupMiddleware();
    this.setupEventHandlers();
  }
  
  private setupMiddleware() {
    // 认证中间件
    this.io.use(async (socket, next) => {
      try {
        const token = socket.handshake.auth.token;
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        socket.data.userId = decoded.userId;
        next();
      } catch (err) {
        next(new Error('Authentication failed'));
      }
    });
  }
  
  private setupEventHandlers() {
    this.io.on('connection', (socket) => {
      console.log(`User ${socket.data.userId} connected`);
      
      // 加入会话
      socket.on('join_session', async (data) => {
        const { session_id } = data;
        socket.join(`session:${session_id}`);
        
        // 发送历史消息
        const messages = await this.getSessionMessages(session_id);
        socket.emit('session_history', messages);
      });
      
      // 发送消息
      socket.on('send_message', async (data) => {
        const { session_id, content, character_id } = data;
        
        // 处理消息
        const response = await this.processMessage({
          session_id,
          content,
          character_id,
          user_id: socket.data.userId
        });
        
        // 流式输出
        if (response.stream) {
          for await (const chunk of response.chunks) {
            socket.to(`session:${session_id}`).emit('message_chunk', {
              session_id,
              chunk,
              message_id: response.message_id
            });
          }
        } else {
          socket.to(`session:${session_id}`).emit('message', {
            session_id,
            message: response.message
          });
        }
      });
    });
  }
}
```

### 3.4 AI 服务集成

#### A. 模型路由器
```typescript
// AI 模型路由器
class AIModelRouter {
  private providers: Map<string, AIProvider>;
  
  constructor() {
    this.providers = new Map([
      ['openai', new OpenAIProvider()],
      ['anthropic', new AnthropicProvider()],
      ['deepseek', new DeepSeekProvider()],
      ['gemini', new GeminiProvider()],
      ['local', new LocalModelProvider()]
    ]);
  }
  
  async route(request: ChatRequest): Promise<ChatResponse> {
    const provider = this.selectProvider(request.model);
    const optimizedPrompt = await this.optimizePrompt(request);
    
    try {
      const response = await provider.chat(optimizedPrompt);
      return this.processResponse(response, request);
    } catch (error) {
      // 故障转移
      return this.fallback(request, error);
    }
  }
  
  private selectProvider(model: string): AIProvider {
    // 根据模型选择提供商
    const providerMap = {
      'gpt-4': 'openai',
      'claude-3': 'anthropic',
      'deepseek-v3': 'deepseek',
      'gemini-pro': 'gemini'
    };
    
    return this.providers.get(providerMap[model]);
  }
  
  private async optimizePrompt(request: ChatRequest) {
    // 提示词优化
    const context = await this.buildContext(request);
    const worldInfo = await this.applyWorldInfo(request);
    const characterCard = await this.getCharacterCard(request.character_id);
    
    return {
      ...request,
      messages: [
        { role: 'system', content: characterCard.system_prompt },
        ...worldInfo.entries,
        ...context.messages,
        { role: 'user', content: request.content }
      ]
    };
  }
  
  private async fallback(request: ChatRequest, error: Error) {
    // 故障转移逻辑
    const fallbackProviders = ['openai', 'anthropic', 'local'];
    
    for (const providerName of fallbackProviders) {
      try {
        const provider = this.providers.get(providerName);
        return await provider.chat(request);
      } catch (e) {
        continue;
      }
    }
    
    throw new Error('All providers failed');
  }
}
```

#### B. 流式输出处理
```typescript
// 流式输出处理器
class StreamingProcessor {
  async *processStream(
    provider: AIProvider,
    request: ChatRequest
  ): AsyncGenerator<string> {
    const stream = await provider.chatStream(request);
    const buffer = new StreamBuffer();
    
    for await (const chunk of stream) {
      // 处理不同提供商的格式差异
      const normalized = this.normalizeChunk(chunk, provider.name);
      
      // 内容过滤
      if (await this.shouldFilter(normalized)) {
        continue;
      }
      
      // 缓冲处理
      buffer.add(normalized);
      
      if (buffer.shouldFlush()) {
        yield buffer.flush();
      }
    }
    
    // 输出剩余内容
    if (buffer.hasContent()) {
      yield buffer.flush();
    }
  }
  
  private normalizeChunk(chunk: any, provider: string): string {
    // 统一不同提供商的输出格式
    switch (provider) {
      case 'openai':
        return chunk.choices[0]?.delta?.content || '';
      case 'anthropic':
        return chunk.completion || '';
      case 'deepseek':
        return chunk.data?.content || '';
      default:
        return String(chunk);
    }
  }
  
  private async shouldFilter(content: string): Promise<boolean> {
    // 内容审核
    return await contentModerator.check(content);
  }
}
```

## 四、性能优化策略

### 4.1 缓存策略
```typescript
// 多级缓存实现
class MultiLevelCache {
  private l1Cache: Map<string, any>;  // 内存缓存
  private l2Cache: Redis;              // Redis 缓存
  private l3Cache: CDN;                // CDN 缓存
  
  async get(key: string): Promise<any> {
    // L1: 内存缓存
    if (this.l1Cache.has(key)) {
      return this.l1Cache.get(key);
    }
    
    // L2: Redis 缓存
    const redisValue = await this.l2Cache.get(key);
    if (redisValue) {
      this.l1Cache.set(key, redisValue);
      return redisValue;
    }
    
    // L3: CDN 缓存（仅用于静态资源）
    if (this.isStaticResource(key)) {
      return await this.l3Cache.get(key);
    }
    
    return null;
  }
  
  async set(key: string, value: any, ttl: number) {
    // 写入所有层级
    this.l1Cache.set(key, value);
    await this.l2Cache.setex(key, ttl, value);
    
    if (this.isStaticResource(key)) {
      await this.l3Cache.set(key, value, ttl);
    }
  }
  
  // 缓存预热
  async warmup() {
    const hotKeys = await this.getHotKeys();
    for (const key of hotKeys) {
      const value = await this.loadFromDatabase(key);
      await this.set(key, value, 3600);
    }
  }
}
```

### 4.2 数据库优化
```sql
-- 索引优化
CREATE INDEX CONCURRENTLY idx_messages_session_timestamp 
ON messages(session_id, timestamp DESC);

CREATE INDEX CONCURRENTLY idx_characters_search 
ON characters USING GIN(
  to_tsvector('english', name || ' ' || description)
);

-- 分区表
CREATE TABLE messages_2024_01 PARTITION OF messages
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 物化视图
CREATE MATERIALIZED VIEW popular_characters AS
SELECT 
  c.*,
  COUNT(DISTINCT cs.user_id) as unique_users,
  AVG(r.rating) as avg_rating
FROM characters c
LEFT JOIN chat_sessions cs ON c.id = ANY(cs.character_ids)
LEFT JOIN ratings r ON c.id = r.character_id
WHERE c.is_public = true
GROUP BY c.id
ORDER BY unique_users DESC, avg_rating DESC;

-- 定期刷新
CREATE EXTENSION pg_cron;
SELECT cron.schedule('refresh-popular', '*/10 * * * *', 
  'REFRESH MATERIALIZED VIEW CONCURRENTLY popular_characters');
```

### 4.3 负载均衡
```nginx
# Nginx 配置
upstream api_servers {
    least_conn;
    server api1.tavernai.com:5000 weight=3;
    server api2.tavernai.com:5000 weight=2;
    server api3.tavernai.com:5000 weight=1;
    
    keepalive 32;
}

upstream websocket_servers {
    ip_hash;  # 保证 WebSocket 连接的会话亲和性
    server ws1.tavernai.com:8080;
    server ws2.tavernai.com:8080;
}

server {
    listen 443 ssl http2;
    server_name api.tavernai.com;
    
    # SSL 配置
    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    
    # API 路由
    location /api/ {
        proxy_pass http://api_servers;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        
        # 缓存配置
        proxy_cache api_cache;
        proxy_cache_valid 200 5m;
        proxy_cache_key $scheme$proxy_host$request_uri;
    }
    
    # WebSocket 路由
    location /ws/ {
        proxy_pass http://websocket_servers;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_read_timeout 86400;
    }
}
```

## 五、安全架构

### 5.1 认证与授权
```typescript
// JWT 认证实现
class AuthService {
  // 生成令牌
  generateTokens(userId: string) {
    const accessToken = jwt.sign(
      { userId, type: 'access' },
      process.env.JWT_SECRET,
      { expiresIn: '15m' }
    );
    
    const refreshToken = jwt.sign(
      { userId, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    return { accessToken, refreshToken };
  }
  
  // RBAC 权限控制
  async checkPermission(
    userId: string,
    resource: string,
    action: string
  ): Promise<boolean> {
    const user = await this.getUserWithRoles(userId);
    
    for (const role of user.roles) {
      const permissions = await this.getRolePermissions(role);
      if (permissions.includes(`${resource}:${action}`)) {
        return true;
      }
    }
    
    return false;
  }
  
  // OAuth2 集成
  setupOAuth() {
    passport.use(new GoogleStrategy({
      clientID: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      callbackURL: "/auth/google/callback"
    }, this.oauthCallback));
    
    passport.use(new DiscordStrategy({
      clientID: process.env.DISCORD_CLIENT_ID,
      clientSecret: process.env.DISCORD_CLIENT_SECRET,
      callbackURL: "/auth/discord/callback"
    }, this.oauthCallback));
  }
}
```

### 5.2 数据加密
```typescript
// 数据加密服务
class EncryptionService {
  private algorithm = 'aes-256-gcm';
  private key: Buffer;
  
  constructor() {
    this.key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
  }
  
  encrypt(data: string): EncryptedData {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);
    
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    };
  }
  
  decrypt(encryptedData: EncryptedData): string {
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      this.key,
      Buffer.from(encryptedData.iv, 'hex')
    );
    
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
  
  // 字段级加密
  encryptFields(obj: any, fields: string[]): any {
    const encrypted = { ...obj };
    
    for (const field of fields) {
      if (obj[field]) {
        encrypted[field] = this.encrypt(obj[field]);
      }
    }
    
    return encrypted;
  }
}
```

### 5.3 安全中间件
```typescript
// 安全中间件集合
class SecurityMiddleware {
  // 速率限制
  rateLimit() {
    return rateLimit({
      windowMs: 60 * 1000,  // 1分钟
      max: 100,              // 最多100个请求
      standardHeaders: true,
      legacyHeaders: false,
      handler: (req, res) => {
        res.status(429).json({
          error: 'Too many requests',
          retryAfter: req.rateLimit.resetTime
        });
      }
    });
  }
  
  // CORS 配置
  cors() {
    return cors({
      origin: (origin, callback) => {
        const allowedOrigins = [
          'https://tavernai.com',
          'https://app.tavernai.com'
        ];
        
        if (!origin || allowedOrigins.includes(origin)) {
          callback(null, true);
        } else {
          callback(new Error('Not allowed by CORS'));
        }
      },
      credentials: true
    });
  }
  
  // 内容安全策略
  contentSecurityPolicy() {
    return helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          scriptSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          imgSrc: ["'self'", "data:", "https:"],
          connectSrc: ["'self'", "wss://ws.tavernai.com"]
        }
      }
    });
  }
  
  // SQL 注入防护
  sqlInjectionProtection() {
    return (req: Request, res: Response, next: NextFunction) => {
      const suspicious = /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|CREATE|ALTER)\b)/gi;
      
      const checkValue = (value: any): boolean => {
        if (typeof value === 'string') {
          return !suspicious.test(value);
        }
        return true;
      };
      
      const validateObject = (obj: any): boolean => {
        for (const key in obj) {
          if (!checkValue(obj[key])) {
            return false;
          }
          if (typeof obj[key] === 'object') {
            if (!validateObject(obj[key])) {
              return false;
            }
          }
        }
        return true;
      };
      
      if (!validateObject(req.body) || !validateObject(req.query)) {
        return res.status(400).json({ error: 'Invalid input detected' });
      }
      
      next();
    };
  }
}
```

## 六、监控与日志

### 6.1 监控系统
```typescript
// 监控指标收集
class MetricsCollector {
  private prometheus: PrometheusClient;
  
  constructor() {
    this.setupMetrics();
  }
  
  private setupMetrics() {
    // HTTP 请求指标
    this.httpDuration = new Histogram({
      name: 'http_request_duration_seconds',
      help: 'Duration of HTTP requests in seconds',
      labelNames: ['method', 'route', 'status'],
      buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
    });
    
    // 活跃用户数
    this.activeUsers = new Gauge({
      name: 'active_users_count',
      help: 'Number of active users'
    });
    
    // AI 模型调用指标
    this.aiCalls = new Counter({
      name: 'ai_model_calls_total',
      help: 'Total number of AI model calls',
      labelNames: ['model', 'status']
    });
    
    // 数据库连接池
    this.dbConnections = new Gauge({
      name: 'database_connections',
      help: 'Number of database connections',
      labelNames: ['state']
    });
  }
  
  // 中间件集成
  middleware() {
    return (req: Request, res: Response, next: NextFunction) => {
      const start = Date.now();
      
      res.on('finish', () => {
        const duration = (Date.now() - start) / 1000;
        this.httpDuration
          .labels(req.method, req.route?.path || 'unknown', res.statusCode.toString())
          .observe(duration);
      });
      
      next();
    };
  }
}
```

### 6.2 日志系统
```typescript
// 结构化日志
class Logger {
  private winston: Winston.Logger;
  
  constructor() {
    this.winston = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      defaultMeta: { 
        service: 'tavernai-plus',
        environment: process.env.NODE_ENV
      },
      transports: [
        // 控制台输出
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        }),
        // 文件输出
        new winston.transports.File({
          filename: 'logs/error.log',
          level: 'error',
          maxsize: 10485760,  // 10MB
          maxFiles: 10
        }),
        new winston.transports.File({
          filename: 'logs/combined.log',
          maxsize: 10485760,
          maxFiles: 30
        })
      ]
    });
    
    // ELK Stack 集成
    if (process.env.LOGSTASH_HOST) {
      this.winston.add(new LogstashTransport({
        host: process.env.LOGSTASH_HOST,
        port: 5000
      }));
    }
  }
  
  // 请求日志
  logRequest(req: Request, res: Response, duration: number) {
    this.winston.info('HTTP Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration,
      ip: req.ip,
      userAgent: req.get('user-agent'),
      userId: req.user?.id
    });
  }
  
  // AI 调用日志
  logAICall(model: string, tokens: number, duration: number, error?: Error) {
    const level = error ? 'error' : 'info';
    this.winston.log(level, 'AI Model Call', {
      model,
      tokens,
      duration,
      cost: this.calculateCost(model, tokens),
      error: error?.message,
      stack: error?.stack
    });
  }
}
```

## 七、部署配置

### 7.1 Docker 配置
```dockerfile
# 多阶段构建 Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY package*.json ./
COPY yarn.lock ./

# 安装依赖
RUN yarn install --frozen-lockfile

# 复制源代码
COPY . .

# 构建
RUN yarn build

# 生产镜像
FROM node:18-alpine

WORKDIR /app

# 安装生产依赖
COPY package*.json ./
COPY yarn.lock ./
RUN yarn install --production --frozen-lockfile

# 复制构建结果
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/public ./public

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js

# 运行
USER node
EXPOSE 5000
CMD ["node", "dist/server.js"]
```

### 7.2 Kubernetes 部署
```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tavernai-api
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: tavernai-api
  template:
    metadata:
      labels:
        app: tavernai-api
    spec:
      containers:
      - name: api
        image: tavernai/api:latest
        ports:
        - containerPort: 5000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: tavernai-api-service
  namespace: production
spec:
  selector:
    app: tavernai-api
  ports:
  - port: 80
    targetPort: 5000
  type: LoadBalancer
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: tavernai-api-hpa
  namespace: production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: tavernai-api
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## 八、总结

本技术架构设计充分利用了 SillyTavern 的现有优势，通过模块化改造和功能扩展，构建了一个高性能、可扩展、安全可靠的 AI 角色扮演平台。关键特性包括：

1. **微服务架构** - 服务解耦，独立部署和扩展
2. **多层缓存** - 内存、Redis、CDN 三级缓存
3. **高可用部署** - Kubernetes 编排，自动扩缩容
4. **全面监控** - Prometheus + Grafana + ELK Stack
5. **安全防护** - 多层安全策略，数据加密
6. **性能优化** - 数据库优化，负载均衡，流式处理

通过这个架构，我们能够支持 10万+ 用户同时在线，处理每秒 1000+ 并发请求，确保系统稳定性和用户体验。