# TavernAI Plus 数据库架构扩展方案

## 📋 项目概述

### 当前状态分析
- **数据库**: SQLite + Prisma ORM
- **数据规模**: 50+用户，100+角色，2000+对话消息
- **架构**: Monorepo (Turbo) + Vue 3 + Node.js + TypeScript
- **已有功能**: 基础的AI角色对话、用户管理、简单评分系统

### 扩展目标
设计支持高级功能的数据库架构，包括：角色市场、多模态AI、社区功能、推荐系统、向量搜索等。

---

## 🎯 一、数据库迁移策略

### 1.1 SQLite → PostgreSQL 迁移方案

#### 迁移时机选择
```sql
-- 当前数据量评估
SELECT 
    'users' as table_name, COUNT(*) as count FROM users
UNION ALL
SELECT 'characters', COUNT(*) FROM characters  
UNION ALL
SELECT 'messages', COUNT(*) FROM messages;
```

#### 迁移步骤
1. **准备阶段** (0-1天)
   - 安装PostgreSQL 15+
   - 配置连接池和复制
   - 准备迁移脚本

2. **数据迁移** (1-2天)
   - 导出SQLite数据
   - 转换数据格式
   - 导入PostgreSQL
   - 验证数据完整性

3. **应用切换** (0.5天)
   - 更新连接字符串
   - 测试所有功能
   - 回滚方案准备

#### 迁移脚本示例
```typescript
// migration-scripts/sqlite-to-postgresql.ts
import { PrismaClient as SQLiteClient } from '@prisma/client-sqlite';
import { PrismaClient as PostgreSQLClient } from '@prisma/client';

export class DatabaseMigrator {
  private sqliteClient: SQLiteClient;
  private postgresClient: PostgreSQLClient;

  async migrate() {
    // 1. 迁移用户数据
    await this.migrateUsers();
    
    // 2. 迁移角色数据
    await this.migrateCharacters();
    
    // 3. 迁移会话和消息
    await this.migrateChatSessions();
    
    // 4. 验证数据完整性
    await this.validateMigration();
  }

  private async migrateUsers() {
    const users = await this.sqliteClient.user.findMany();
    
    for (const user of users) {
      await this.postgresClient.user.create({
        data: {
          ...user,
          metadata: typeof user.metadata === 'string' 
            ? JSON.parse(user.metadata || '{}') 
            : user.metadata
        }
      });
    }
  }

  private async validateMigration() {
    const sqliteCount = await this.sqliteClient.user.count();
    const postgresCount = await this.postgresClient.user.count();
    
    if (sqliteCount !== postgresCount) {
      throw new Error(`User count mismatch: SQLite=${sqliteCount}, PostgreSQL=${postgresCount}`);
    }
  }
}
```

### 1.2 数据完整性保障

#### 迁移前检查
```sql
-- 检查数据一致性
SELECT 
    c.id,
    COUNT(DISTINCT cs.id) as session_count,
    COUNT(DISTINCT m.id) as message_count
FROM characters c
LEFT JOIN chat_sessions cs ON c.id = cs.character_id
LEFT JOIN messages m ON cs.id = m.session_id
GROUP BY c.id
HAVING session_count > 0 AND message_count = 0; -- 发现不一致数据
```

#### 回滚机制
```typescript
// rollback-manager.ts
export class RollbackManager {
  async createBackup() {
    // SQLite 备份
    await this.backupSQLite();
    
    // PostgreSQL 快照
    await this.createPostgreSQLSnapshot();
  }

  async rollback() {
    // 恢复SQLite数据库
    await this.restoreSQLite();
    
    // 更新应用配置
    await this.updateDatabaseConfig('sqlite');
  }
}
```

---

## 🏗️ 二、扩展数据库架构设计

### 2.1 角色市场和分享功能

```sql
-- 角色版本管理
CREATE TABLE character_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    changes JSONB, -- 版本变更说明
    published_by UUID REFERENCES users(id),
    is_published BOOLEAN DEFAULT false,
    download_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(character_id, version_number)
);

-- 角色发布和审核
CREATE TABLE character_publications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    publisher_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    tags TEXT[], -- PostgreSQL 数组类型
    category_id UUID REFERENCES character_categories(id),
    price DECIMAL(10,2) DEFAULT 0.00, -- 付费角色支持
    license_type VARCHAR(50) DEFAULT 'free', -- free, premium, exclusive
    status VARCHAR(20) DEFAULT 'pending', -- pending, approved, rejected, unlisted
    rejection_reason TEXT,
    featured_until TIMESTAMP,
    download_count INTEGER DEFAULT 0,
    revenue DECIMAL(10,2) DEFAULT 0.00,
    reviewed_by UUID REFERENCES users(id),
    reviewed_at TIMESTAMP,
    published_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 角色分类体系
CREATE TABLE character_categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    parent_id UUID REFERENCES character_categories(id),
    icon VARCHAR(255),
    sort_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 角色下载记录
CREATE TABLE character_downloads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    price_paid DECIMAL(10,2) DEFAULT 0.00,
    payment_id UUID REFERENCES transactions(id),
    download_url VARCHAR(500), -- 临时下载链接
    expires_at TIMESTAMP,
    downloaded_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(character_id, user_id, version_number)
);

-- 创作者收益分成
CREATE TABLE creator_earnings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    creator_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    downloads INTEGER DEFAULT 0,
    gross_revenue DECIMAL(10,2) DEFAULT 0.00,
    platform_fee DECIMAL(10,2) DEFAULT 0.00,
    net_revenue DECIMAL(10,2) DEFAULT 0.00,
    payout_status VARCHAR(20) DEFAULT 'pending', -- pending, processing, paid
    payout_date DATE,
    created_at TIMESTAMP DEFAULT NOW()
);
```

### 2.2 多模态AI支持

```sql
-- 媒体文件管理
CREATE TABLE media_files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    character_id UUID REFERENCES characters(id) ON DELETE CASCADE,
    filename VARCHAR(255) NOT NULL,
    original_name VARCHAR(255) NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    file_size BIGINT NOT NULL,
    storage_path VARCHAR(500) NOT NULL,
    storage_type VARCHAR(20) DEFAULT 'local', -- local, s3, oss
    width INTEGER, -- 图片/视频宽度
    height INTEGER, -- 图片/视频高度
    duration REAL, -- 音频/视频时长(秒)
    metadata JSONB DEFAULT '{}',
    processing_status VARCHAR(20) DEFAULT 'pending', -- pending, processing, completed, failed
    is_public BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 语音配置
CREATE TABLE voice_configurations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    voice_provider VARCHAR(50) NOT NULL, -- elevenlabs, azure, google
    voice_id VARCHAR(100) NOT NULL,
    voice_name VARCHAR(100),
    language VARCHAR(10) DEFAULT 'zh-CN',
    speed REAL DEFAULT 1.0,
    pitch REAL DEFAULT 1.0,
    stability REAL DEFAULT 0.5,
    similarity REAL DEFAULT 0.5,
    style_exaggeration REAL DEFAULT 0.0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 多媒体消息
CREATE TABLE multimedia_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
    media_file_id UUID NOT NULL REFERENCES media_files(id) ON DELETE CASCADE,
    media_type VARCHAR(20) NOT NULL, -- image, audio, video, document
    generated_by VARCHAR(50), -- midjourney, dalle, elevenlabs, user_upload
    prompt_used TEXT, -- 生成时使用的提示词
    generation_params JSONB, -- 生成参数
    processing_time INTEGER, -- 处理时间(毫秒)
    created_at TIMESTAMP DEFAULT NOW()
);

-- 图像生成历史
CREATE TABLE image_generations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    character_id UUID REFERENCES characters(id) ON DELETE SET NULL,
    prompt TEXT NOT NULL,
    negative_prompt TEXT,
    model VARCHAR(50) NOT NULL, -- dalle-3, midjourney, stable-diffusion
    width INTEGER DEFAULT 1024,
    height INTEGER DEFAULT 1024,
    steps INTEGER DEFAULT 20,
    guidance_scale REAL DEFAULT 7.5,
    seed BIGINT,
    generated_images JSONB, -- 生成的图片URL数组
    status VARCHAR(20) DEFAULT 'pending', -- pending, generating, completed, failed
    error_message TEXT,
    generation_time INTEGER, -- 生成时间(毫秒)
    cost DECIMAL(8,4) DEFAULT 0.0000, -- 生成成本
    created_at TIMESTAMP DEFAULT NOW(),
    completed_at TIMESTAMP
);

-- 语音合成历史
CREATE TABLE speech_synthesis (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    character_id UUID REFERENCES characters(id) ON DELETE SET NULL,
    text TEXT NOT NULL,
    voice_config_id UUID REFERENCES voice_configurations(id),
    provider VARCHAR(50) NOT NULL,
    voice_id VARCHAR(100) NOT NULL,
    audio_file_id UUID REFERENCES media_files(id),
    status VARCHAR(20) DEFAULT 'pending',
    error_message TEXT,
    synthesis_time INTEGER,
    cost DECIMAL(8,4) DEFAULT 0.0000,
    created_at TIMESTAMP DEFAULT NOW(),
    completed_at TIMESTAMP
);
```

### 2.3 社区功能和用户互动

```sql
-- 用户关系(关注/粉丝)
CREATE TABLE user_relationships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    follower_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    following_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'active', -- active, blocked, muted
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(follower_id, following_id),
    CHECK(follower_id != following_id)
);

-- 社区动态
CREATE TABLE user_activities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    activity_type VARCHAR(50) NOT NULL, -- post, share_character, rate_character, achievement
    target_type VARCHAR(50), -- character, user, post
    target_id UUID, -- 目标对象ID
    content TEXT,
    media_files UUID[], -- 媒体文件ID数组
    metadata JSONB DEFAULT '{}',
    visibility VARCHAR(20) DEFAULT 'public', -- public, friends, private
    like_count INTEGER DEFAULT 0,
    comment_count INTEGER DEFAULT 0,
    share_count INTEGER DEFAULT 0,
    is_pinned BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 动态互动(点赞、评论、分享)
CREATE TABLE activity_interactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    activity_id UUID NOT NULL REFERENCES user_activities(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    interaction_type VARCHAR(20) NOT NULL, -- like, comment, share, report
    content TEXT, -- 评论内容
    parent_id UUID REFERENCES activity_interactions(id), -- 回复的评论ID
    is_deleted BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(activity_id, user_id, interaction_type) -- 每种类型只能交互一次
);

-- 社区话题和讨论组
CREATE TABLE community_topics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    creator_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(50) NOT NULL, -- general, character-creation, roleplay, technical
    tags TEXT[],
    rules JSONB, -- 话题规则
    is_official BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true,
    member_count INTEGER DEFAULT 0,
    post_count INTEGER DEFAULT 0,
    avatar VARCHAR(255),
    banner VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 话题成员
CREATE TABLE topic_members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    topic_id UUID NOT NULL REFERENCES community_topics(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(20) DEFAULT 'member', -- owner, moderator, member
    permissions JSONB DEFAULT '{}', -- 权限配置
    joined_at TIMESTAMP DEFAULT NOW(),
    last_active_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(topic_id, user_id)
);

-- 通知系统
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    sender_id UUID REFERENCES users(id) ON DELETE SET NULL,
    type VARCHAR(50) NOT NULL, -- follow, like, comment, share, system, achievement
    title VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    action_url VARCHAR(500), -- 点击通知跳转的URL
    metadata JSONB DEFAULT '{}',
    is_read BOOLEAN DEFAULT false,
    is_deleted BOOLEAN DEFAULT false,
    priority VARCHAR(20) DEFAULT 'normal', -- low, normal, high, urgent
    expires_at TIMESTAMP, -- 通知过期时间
    created_at TIMESTAMP DEFAULT NOW()
);

-- 用户收藏夹
CREATE TABLE user_collections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    is_public BOOLEAN DEFAULT false,
    item_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 收藏夹项目
CREATE TABLE collection_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    collection_id UUID NOT NULL REFERENCES user_collections(id) ON DELETE CASCADE,
    item_type VARCHAR(50) NOT NULL, -- character, activity, topic
    item_id UUID NOT NULL,
    notes TEXT, -- 用户备注
    sort_order INTEGER DEFAULT 0,
    added_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(collection_id, item_type, item_id)
);
```

### 2.4 向量数据库和AI功能

```sql
-- 向量存储扩展 (使用 pgvector)
CREATE EXTENSION IF NOT EXISTS vector;

-- 角色向量化表示
CREATE TABLE character_embeddings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    embedding_type VARCHAR(50) NOT NULL, -- description, personality, full_profile
    embedding vector(1536), -- OpenAI text-embedding-ada-002 维度
    model_name VARCHAR(100) NOT NULL, -- text-embedding-ada-002, text-embedding-3-large
    content_hash VARCHAR(64) NOT NULL, -- 内容哈希，用于检测是否需要重新生成
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(character_id, embedding_type, model_name)
);

-- 为向量搜索创建索引
CREATE INDEX idx_character_embeddings_vector ON character_embeddings 
USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

-- 对话上下文向量化
CREATE TABLE conversation_embeddings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE,
    message_window_start INTEGER NOT NULL, -- 窗口开始消息位置
    message_window_end INTEGER NOT NULL, -- 窗口结束消息位置
    summary TEXT, -- 对话摘要
    embedding vector(1536),
    model_name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(session_id, message_window_start, message_window_end)
);

-- 长期记忆存储
CREATE TABLE character_memories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    memory_type VARCHAR(50) NOT NULL, -- fact, preference, event, relationship
    content TEXT NOT NULL,
    importance_score REAL DEFAULT 0.5, -- 0-1 重要性评分
    confidence_score REAL DEFAULT 1.0, -- 0-1 置信度
    embedding vector(1536),
    tags TEXT[],
    source_session_id UUID REFERENCES chat_sessions(id),
    source_message_id UUID REFERENCES messages(id),
    is_active BOOLEAN DEFAULT true,
    last_accessed_at TIMESTAMP,
    access_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 角色情感状态历史
CREATE TABLE character_emotional_states (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    session_id UUID NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE,
    emotional_state JSONB NOT NULL, -- {joy: 0.3, sadness: 0.1, anger: 0.05, ...}
    trigger_event TEXT, -- 触发情感变化的事件
    context_summary TEXT,
    intensity REAL DEFAULT 0.5, -- 情感强度 0-1
    duration_minutes INTEGER, -- 情感持续时间
    decay_rate REAL DEFAULT 0.1, -- 情感衰减率
    created_at TIMESTAMP DEFAULT NOW()
);

-- AI 学习进度和知识积累
CREATE TABLE character_learning_progress (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    skill_type VARCHAR(100) NOT NULL, -- conversation, humor, empathy, domain_knowledge
    current_level REAL DEFAULT 0.0, -- 当前水平 0-100
    experience_points INTEGER DEFAULT 0,
    learning_data JSONB DEFAULT '{}', -- 学习相关数据
    last_improvement_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(character_id, user_id, skill_type)
);

-- 上下文感知配置
CREATE TABLE context_awareness_configs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    character_id UUID NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    config_name VARCHAR(100) NOT NULL,
    context_window_size INTEGER DEFAULT 4000, -- token数量
    memory_retrieval_count INTEGER DEFAULT 5, -- 检索记忆数量
    emotion_influence_weight REAL DEFAULT 0.3, -- 情感影响权重
    learning_adaptation_rate REAL DEFAULT 0.1, -- 学习适应率
    personality_consistency_weight REAL DEFAULT 0.8, -- 人格一致性权重
    context_filters JSONB DEFAULT '{}', -- 上下文过滤器
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(character_id, config_name)
);
```

### 2.5 个性化推荐系统

```sql
-- 用户行为跟踪
CREATE TABLE user_behavior_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    action_type VARCHAR(50) NOT NULL, -- view, chat, rate, favorite, share, download
    target_type VARCHAR(50) NOT NULL, -- character, user, activity, topic
    target_id UUID NOT NULL,
    session_id VARCHAR(100), -- 前端会话ID
    duration_seconds INTEGER, -- 行为持续时间
    context JSONB DEFAULT '{}', -- 行为上下文(页面来源、搜索词等)
    device_info JSONB DEFAULT '{}', -- 设备信息
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 物品特征矩阵
CREATE TABLE item_features (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    item_type VARCHAR(50) NOT NULL, -- character, topic, activity
    item_id UUID NOT NULL,
    feature_vector vector(512), -- 特征向量
    categorical_features JSONB DEFAULT '{}', -- 分类特征
    numerical_features JSONB DEFAULT '{}', -- 数值特征
    popularity_score REAL DEFAULT 0.0,
    quality_score REAL DEFAULT 0.0,
    recency_score REAL DEFAULT 0.0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(item_type, item_id)
);

-- 用户偏好向量
CREATE TABLE user_preference_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    profile_type VARCHAR(50) NOT NULL, -- character_preferences, topic_preferences
    preference_vector vector(512),
    explicit_preferences JSONB DEFAULT '{}', -- 明确偏好
    implicit_preferences JSONB DEFAULT '{}', -- 隐式偏好
    confidence_score REAL DEFAULT 0.5,
    last_computed_at TIMESTAMP DEFAULT NOW(),
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(user_id, profile_type)
);

-- 推荐结果缓存
CREATE TABLE recommendation_cache (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    recommendation_type VARCHAR(50) NOT NULL, -- similar_characters, trending_topics, personalized_feed
    algorithm_version VARCHAR(20) NOT NULL,
    items JSONB NOT NULL, -- 推荐项目列表
    scores JSONB NOT NULL, -- 对应的评分
    explanation JSONB, -- 推荐解释
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(user_id, recommendation_type, algorithm_version)
);

-- A/B测试配置
CREATE TABLE ab_test_experiments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    description TEXT,
    status VARCHAR(20) DEFAULT 'draft', -- draft, running, completed, paused
    start_date DATE,
    end_date DATE,
    traffic_percentage REAL DEFAULT 100.0, -- 参与测试的流量百分比
    variants JSONB NOT NULL, -- 实验变体配置
    target_metrics TEXT[], -- 目标指标
    success_criteria JSONB, -- 成功标准
    created_by UUID NOT NULL REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- A/B测试参与记录
CREATE TABLE ab_test_participations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    experiment_id UUID NOT NULL REFERENCES ab_test_experiments(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    variant_name VARCHAR(100) NOT NULL,
    assigned_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(experiment_id, user_id)
);

-- A/B测试指标收集
CREATE TABLE ab_test_metrics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    experiment_id UUID NOT NULL REFERENCES ab_test_experiments(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    variant_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value REAL NOT NULL,
    metadata JSONB DEFAULT '{}',
    recorded_at TIMESTAMP DEFAULT NOW()
);
```

---

## 🚀 三、技术架构实现

### 3.1 扩展的Prisma Schema

```typescript
// prisma/schema-extended.prisma
generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
  previewFeatures = ["jsonProtocol", "postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [vector]
}

// 扩展现有模型
model Character {
  // ... 现有字段 ...
  
  // 新增字段
  aiModel            String?               @default("gpt-3.5-turbo")
  voiceProvider      String?               @default("elevenlabs")
  emotionalRange     Float                 @default(1.0) // 情感表达范围
  learningEnabled    Boolean               @default(true)
  memoryRetention    Int                   @default(100) // 记忆保留数量
  contextAwareness   Float                 @default(0.8) // 上下文感知度
  
  // 新关系
  versions           CharacterVersion[]
  publications       CharacterPublication[]
  downloads          CharacterDownload[]
  earnings           CreatorEarning[]
  embeddings         CharacterEmbedding[]
  memories           CharacterMemory[]
  emotionalStates    CharacterEmotionalState[]
  learningProgress   CharacterLearningProgress[]
  contextConfigs     ContextAwarenessConfig[]
  voiceConfigs       VoiceConfiguration[]
}

model User {
  // ... 现有字段 ...
  
  // 新增字段
  preferredLanguages String[]              @default(["zh-CN"])
  contentFilters     Json                  @default("{}")
  privacySettings    Json                  @default("{}")
  notificationPrefs  Json                  @default("{}")
  subscriptionFeatures Json               @default("{}")
  
  // 新关系
  followers          UserRelationship[]    @relation("UserFollowers")
  following          UserRelationship[]    @relation("UserFollowing")
  activities         UserActivity[]
  interactions       ActivityInteraction[]
  collections        UserCollection[]
  behaviorLogs       UserBehaviorLog[]
  preferenceProfiles UserPreferenceProfile[]
  notifications      Notification[]
  topicMemberships   TopicMember[]
  mediaFiles         MediaFile[]
  imageGenerations   ImageGeneration[]
  speechSynthesis    SpeechSynthesis[]
  abTestParticipations ABTestParticipation[]
}

// 新模型定义
model CharacterVersion {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  characterId     String    @db.Uuid
  versionNumber   Int
  name            String    @db.VarChar(255)
  description     String?   @db.Text
  changes         Json?
  publishedBy     String?   @db.Uuid
  isPublished     Boolean   @default(false)
  downloadCount   Int       @default(0)
  createdAt       DateTime  @default(now())
  
  character       Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  publisher       User?     @relation(fields: [publishedBy], references: [id])
  
  @@unique([characterId, versionNumber])
}

model UserRelationship {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  followerId   String   @db.Uuid
  followingId  String   @db.Uuid
  status       String   @default("active") @db.VarChar(20)
  createdAt    DateTime @default(now())
  
  follower     User     @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  following    User     @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)
  
  @@unique([followerId, followingId])
}

// Unsupported 类型 - 需要原生SQL创建
// model CharacterEmbedding {
//   id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
//   characterId   String    @db.Uuid
//   embeddingType String    @db.VarChar(50)
//   embedding     Unsupported("vector(1536)")  // 向量类型
//   modelName     String    @db.VarChar(100)
//   contentHash   String    @db.VarChar(64)
//   metadata      Json      @default("{}")
//   createdAt     DateTime  @default(now())
//   updatedAt     DateTime  @updatedAt
//   
//   character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
//   
//   @@unique([characterId, embeddingType, modelName])
// }
```

### 3.2 向量数据库集成

```typescript
// services/vector-service.ts
import { Pool } from 'pg';

export class VectorService {
  private pool: Pool;

  constructor() {
    this.pool = new Pool({
      connectionString: process.env.DATABASE_URL
    });
  }

  async generateCharacterEmbedding(characterId: string): Promise<void> {
    const character = await prisma.character.findUnique({
      where: { id: characterId },
      include: { creator: true }
    });

    if (!character) throw new Error('Character not found');

    // 生成embedding
    const embedding = await this.createEmbedding(
      `${character.name} ${character.description} ${character.personality}`
    );

    // 存储向量
    await this.pool.query(`
      INSERT INTO character_embeddings (character_id, embedding_type, embedding, model_name, content_hash)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (character_id, embedding_type, model_name) 
      DO UPDATE SET 
        embedding = EXCLUDED.embedding,
        content_hash = EXCLUDED.content_hash,
        updated_at = NOW()
    `, [
      characterId,
      'full_profile',
      JSON.stringify(embedding),
      'text-embedding-ada-002',
      this.generateContentHash(character)
    ]);
  }

  async findSimilarCharacters(characterId: string, limit: number = 10): Promise<string[]> {
    const result = await this.pool.query(`
      SELECT 
        ce2.character_id,
        1 - (ce1.embedding <=> ce2.embedding) as similarity
      FROM character_embeddings ce1
      JOIN character_embeddings ce2 ON ce1.embedding_type = ce2.embedding_type
      WHERE ce1.character_id = $1 
        AND ce2.character_id != $1
        AND ce1.embedding_type = 'full_profile'
      ORDER BY ce1.embedding <=> ce2.embedding
      LIMIT $2
    `, [characterId, limit]);

    return result.rows.map(row => row.character_id);
  }

  async searchCharactersBySemantics(query: string, limit: number = 20): Promise<Array<{id: string, similarity: number}>> {
    const queryEmbedding = await this.createEmbedding(query);
    
    const result = await this.pool.query(`
      SELECT 
        character_id as id,
        1 - (embedding <=> $1) as similarity
      FROM character_embeddings
      WHERE embedding_type = 'full_profile'
      ORDER BY embedding <=> $1
      LIMIT $2
    `, [JSON.stringify(queryEmbedding), limit]);

    return result.rows;
  }

  private async createEmbedding(text: string): Promise<number[]> {
    // 调用 OpenAI Embedding API
    const response = await fetch('https://api.openai.com/v1/embeddings', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'text-embedding-ada-002',
        input: text
      })
    });

    const data = await response.json();
    return data.data[0].embedding;
  }

  private generateContentHash(character: any): string {
    const crypto = require('crypto');
    const content = `${character.name}${character.description}${character.personality}${character.updatedAt}`;
    return crypto.createHash('sha256').update(content).digest('hex');
  }
}
```

### 3.3 Redis缓存策略

```typescript
// services/cache-service.ts
import Redis from 'ioredis';

export class CacheService {
  private redis: Redis;

  constructor() {
    this.redis = new Redis(process.env.REDIS_URL);
  }

  // 角色信息缓存
  async cacheCharacter(characterId: string, character: any, ttl: number = 3600) {
    await this.redis.setex(
      `character:${characterId}`, 
      ttl, 
      JSON.stringify(character)
    );
  }

  async getCachedCharacter(characterId: string): Promise<any | null> {
    const cached = await this.redis.get(`character:${characterId}`);
    return cached ? JSON.parse(cached) : null;
  }

  // 推荐结果缓存
  async cacheRecommendations(userId: string, type: string, recommendations: any[], ttl: number = 1800) {
    await this.redis.setex(
      `recommendations:${userId}:${type}`,
      ttl,
      JSON.stringify(recommendations)
    );
  }

  // 热门内容缓存
  async cacheTrendingCharacters(characters: any[], ttl: number = 3600) {
    await this.redis.setex(
      'trending:characters',
      ttl,
      JSON.stringify(characters)
    );
  }

  // 用户会话缓存
  async cacheUserSession(sessionId: string, sessionData: any, ttl: number = 7200) {
    await this.redis.setex(
      `session:${sessionId}`,
      ttl,
      JSON.stringify(sessionData)
    );
  }

  // 分布式锁
  async acquireLock(key: string, ttl: number = 30): Promise<boolean> {
    const result = await this.redis.set(
      `lock:${key}`,
      '1',
      'EX',
      ttl,
      'NX'
    );
    return result === 'OK';
  }

  async releaseLock(key: string): Promise<void> {
    await this.redis.del(`lock:${key}`);
  }

  // 计数器(点赞、下载等)
  async incrementCounter(key: string, ttl?: number): Promise<number> {
    const multi = this.redis.multi();
    multi.incr(key);
    if (ttl) multi.expire(key, ttl);
    const results = await multi.exec();
    return results?.[0]?.[1] as number || 0;
  }

  // 实时统计
  async addToSortedSet(key: string, score: number, member: string, ttl?: number): Promise<void> {
    const multi = this.redis.multi();
    multi.zadd(key, score, member);
    if (ttl) multi.expire(key, ttl);
    await multi.exec();
  }

  async getTopFromSortedSet(key: string, count: number = 10): Promise<Array<{member: string, score: number}>> {
    const results = await this.redis.zrevrange(key, 0, count - 1, 'WITHSCORES');
    const items = [];
    for (let i = 0; i < results.length; i += 2) {
      items.push({
        member: results[i],
        score: parseFloat(results[i + 1])
      });
    }
    return items;
  }
}
```

### 3.4 数据分析和ETL管道

```typescript
// services/analytics-service.ts
export class AnalyticsService {
  async collectUserBehavior(data: {
    userId: string;
    actionType: string;
    targetType: string;
    targetId: string;
    duration?: number;
    context?: any;
  }) {
    // 实时记录到数据库
    await prisma.userBehaviorLog.create({
      data: {
        userId: data.userId,
        actionType: data.actionType,
        targetType: data.targetType,
        targetId: data.targetId,
        durationSeconds: data.duration,
        context: data.context || {},
        deviceInfo: await this.getDeviceInfo(),
        createdAt: new Date()
      }
    });

    // 异步更新实时统计
    await this.updateRealTimeStats(data);
  }

  async generateDailyReport(date: Date) {
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);
    
    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);

    // 用户活跃度统计
    const userStats = await prisma.$queryRaw`
      SELECT 
        COUNT(DISTINCT user_id) as active_users,
        COUNT(*) as total_actions,
        AVG(duration_seconds) as avg_session_duration
      FROM user_behavior_logs 
      WHERE created_at BETWEEN ${startOfDay} AND ${endOfDay}
    `;

    // 角色使用统计
    const characterStats = await prisma.$queryRaw`
      SELECT 
        target_id as character_id,
        COUNT(*) as interaction_count,
        COUNT(DISTINCT user_id) as unique_users
      FROM user_behavior_logs 
      WHERE target_type = 'character'
        AND action_type IN ('chat', 'view')
        AND created_at BETWEEN ${startOfDay} AND ${endOfDay}
      GROUP BY target_id
      ORDER BY interaction_count DESC
      LIMIT 50
    `;

    return {
      date: date.toISOString().split('T')[0],
      userStats: userStats[0],
      topCharacters: characterStats
    };
  }

  async updateUserPreferences(userId: string) {
    // 分析用户行为，更新偏好向量
    const recentBehaviors = await prisma.userBehaviorLog.findMany({
      where: {
        userId,
        createdAt: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // 最近30天
        }
      },
      include: {
        // 相关联的目标对象信息
      }
    });

    // 计算偏好向量
    const preferenceVector = await this.calculatePreferenceVector(recentBehaviors);
    
    // 更新用户偏好档案
    await prisma.userPreferenceProfile.upsert({
      where: {
        userId_profileType: {
          userId,
          profileType: 'character_preferences'
        }
      },
      update: {
        preferenceVector: JSON.stringify(preferenceVector),
        lastComputedAt: new Date()
      },
      create: {
        userId,
        profileType: 'character_preferences',
        preferenceVector: JSON.stringify(preferenceVector),
        lastComputedAt: new Date()
      }
    });
  }

  private async updateRealTimeStats(data: any) {
    const cache = new CacheService();
    
    // 更新实时计数器
    await cache.incrementCounter(`stats:daily:${data.actionType}:${new Date().toISOString().split('T')[0]}`);
    
    // 更新热门排行榜
    if (data.targetType === 'character') {
      await cache.addToSortedSet(
        'trending:characters:hourly',
        Date.now(),
        data.targetId,
        3600 // 1小时过期
      );
    }
  }

  private async calculatePreferenceVector(behaviors: any[]): Promise<number[]> {
    // 基于用户行为计算偏好向量的算法
    // 这里简化为示例，实际实现会更复杂
    const vector = new Array(512).fill(0);
    
    for (const behavior of behaviors) {
      // 根据行为类型和目标特征更新向量
      // 实际实现需要结合机器学习算法
    }
    
    return vector;
  }

  private async getDeviceInfo(): Promise<any> {
    // 从请求头获取设备信息
    return {
      platform: 'web',
      version: '1.0.0'
    };
  }
}
```

---

## 🔧 四、迁移实施方案

### 4.1 迁移时间表

```typescript
// migration/migration-plan.ts
export const MIGRATION_PHASES = {
  PHASE_1: {
    name: "数据库迁移准备",
    duration: "1-2天",
    tasks: [
      "PostgreSQL环境搭建",
      "pgvector扩展安装", 
      "Redis集群配置",
      "数据备份脚本准备"
    ]
  },
  PHASE_2: {
    name: "核心数据迁移",
    duration: "1天", 
    tasks: [
      "用户和角色数据迁移",
      "聊天会话和消息迁移",
      "评分和收藏关系迁移",
      "数据完整性验证"
    ]
  },
  PHASE_3: {
    name: "扩展功能实现",
    duration: "3-5天",
    tasks: [
      "向量化表结构创建",
      "社区功能表创建", 
      "推荐系统表创建",
      "多媒体支持表创建"
    ]
  },
  PHASE_4: {
    name: "服务层适配",
    duration: "2-3天",
    tasks: [
      "Prisma schema更新",
      "API接口适配",
      "缓存策略实施",
      "性能优化调整"
    ]
  },
  PHASE_5: {
    name: "测试和上线",
    duration: "2天",
    tasks: [
      "功能回归测试",
      "性能压力测试", 
      "数据一致性检查",
      "正式环境切换"
    ]
  }
};
```

### 4.2 迁移脚本

```typescript
// migration/migrate-to-postgresql.ts
import { PrismaClient as SQLiteClient } from '@prisma/client-sqlite';
import { PrismaClient as PostgreSQLClient } from '@prisma/client';

export class DatabaseMigrator {
  private sqliteClient: SQLiteClient;
  private postgresClient: PostgreSQLClient;
  private batchSize = 1000;

  constructor() {
    this.sqliteClient = new SQLiteClient({
      datasources: { db: { url: 'file:./dev.db' } }
    });
    this.postgresClient = new PostgreSQLClient();
  }

  async migrate() {
    console.log('🚀 开始数据库迁移...');
    
    try {
      // 1. 创建备份
      await this.createBackup();
      
      // 2. 迁移核心数据
      await this.migrateUsers();
      await this.migrateCharacters();
      await this.migrateChatSessions();
      await this.migrateMessages();
      await this.migrateRatingsAndFavorites();
      
      // 3. 创建扩展表结构
      await this.createExtendedTables();
      
      // 4. 验证数据完整性
      await this.validateMigration();
      
      console.log('✅ 数据库迁移完成');
      
    } catch (error) {
      console.error('❌ 迁移失败:', error);
      await this.rollback();
      throw error;
    }
  }

  private async migrateUsers() {
    console.log('📤 迁移用户数据...');
    
    const totalUsers = await this.sqliteClient.user.count();
    let migratedCount = 0;

    while (migratedCount < totalUsers) {
      const users = await this.sqliteClient.user.findMany({
        skip: migratedCount,
        take: this.batchSize,
        include: {
          oauthAccounts: true,
          refreshTokens: true
        }
      });

      for (const user of users) {
        await this.postgresClient.user.create({
          data: {
            ...user,
            // 处理JSON字段
            metadata: typeof user.metadata === 'string' 
              ? JSON.parse(user.metadata || '{}') 
              : user.metadata,
            // 创建关联数据
            oauthAccounts: {
              create: user.oauthAccounts.map(account => ({
                provider: account.provider,
                providerId: account.providerId,
                accessToken: account.accessToken,
                refreshToken: account.refreshToken,
                expiresAt: account.expiresAt,
                createdAt: account.createdAt,
                updatedAt: account.updatedAt
              }))
            },
            refreshTokens: {
              create: user.refreshTokens.map(token => ({
                token: token.token,
                expiresAt: token.expiresAt,
                createdAt: token.createdAt
              }))
            }
          }
        });
      }

      migratedCount += users.length;
      console.log(`📊 已迁移用户: ${migratedCount}/${totalUsers}`);
    }
  }

  private async migrateCharacters() {
    console.log('📤 迁移角色数据...');
    
    const totalCharacters = await this.sqliteClient.character.count();
    let migratedCount = 0;

    while (migratedCount < totalCharacters) {
      const characters = await this.sqliteClient.character.findMany({
        skip: migratedCount,
        take: this.batchSize
      });

      for (const character of characters) {
        await this.postgresClient.character.create({
          data: {
            ...character,
            // 处理数组字段
            tags: typeof character.tags === 'string' 
              ? JSON.parse(character.tags || '[]') 
              : character.tags,
            // 处理JSON字段
            metadata: typeof character.metadata === 'string'
              ? JSON.parse(character.metadata || '{}')
              : character.metadata,
            // 处理可能的类型转换
            temperature: character.temperature || 0.7,
            maxTokens: character.maxTokens || 1000
          }
        });
      }

      migratedCount += characters.length;
      console.log(`📊 已迁移角色: ${migratedCount}/${totalCharacters}`);
    }
  }

  private async createExtendedTables() {
    console.log('🏗️ 创建扩展表结构...');
    
    // 执行扩展表的SQL创建脚本
    const extendedSQL = await import('./extended-tables.sql');
    await this.postgresClient.$executeRawUnsafe(extendedSQL.default);
  }

  private async validateMigration() {
    console.log('🔍 验证数据完整性...');
    
    const validations = [
      {
        name: '用户数量',
        sqlite: await this.sqliteClient.user.count(),
        postgres: await this.postgresClient.user.count()
      },
      {
        name: '角色数量',
        sqlite: await this.sqliteClient.character.count(),
        postgres: await this.postgresClient.character.count()
      },
      {
        name: '消息数量',
        sqlite: await this.sqliteClient.message.count(),
        postgres: await this.postgresClient.message.count()
      }
    ];

    for (const validation of validations) {
      if (validation.sqlite !== validation.postgres) {
        throw new Error(
          `${validation.name}不匹配: SQLite=${validation.sqlite}, PostgreSQL=${validation.postgres}`
        );
      }
      console.log(`✅ ${validation.name}: ${validation.postgres}`);
    }
  }

  private async createBackup() {
    console.log('💾 创建数据备份...');
    // 实现备份逻辑
  }

  private async rollback() {
    console.log('🔄 执行回滚操作...');
    // 实现回滚逻辑
  }
}
```

### 4.3 性能优化配置

```sql
-- performance/postgresql-optimization.sql

-- 数据库配置优化
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';
ALTER SYSTEM SET work_mem = '4MB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
ALTER SYSTEM SET wal_buffers = '16MB';
ALTER SYSTEM SET default_statistics_target = 100;
SELECT pg_reload_conf();

-- 创建必要的索引
CREATE INDEX CONCURRENTLY idx_user_behavior_logs_user_action 
ON user_behavior_logs(user_id, action_type, created_at DESC);

CREATE INDEX CONCURRENTLY idx_character_embeddings_similarity 
ON character_embeddings USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

CREATE INDEX CONCURRENTLY idx_characters_public_featured 
ON characters(is_public, is_featured, rating DESC) WHERE is_public = true;

CREATE INDEX CONCURRENTLY idx_messages_session_created 
ON messages(session_id, created_at DESC);

-- 分区表设置(针对大表)
CREATE TABLE user_behavior_logs_partitioned (
    LIKE user_behavior_logs INCLUDING ALL
) PARTITION BY RANGE (created_at);

-- 创建月度分区
CREATE TABLE user_behavior_logs_y2024m01 PARTITION OF user_behavior_logs_partitioned
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 自动化分区管理
CREATE OR REPLACE FUNCTION create_monthly_partition()
RETURNS void AS $$
DECLARE
    start_date date;
    end_date date;
    table_name text;
BEGIN
    start_date := date_trunc('month', CURRENT_DATE + interval '1 month');
    end_date := start_date + interval '1 month';
    table_name := 'user_behavior_logs_y' || extract(year from start_date) || 'm' || lpad(extract(month from start_date)::text, 2, '0');
    
    EXECUTE format('CREATE TABLE %I PARTITION OF user_behavior_logs_partitioned FOR VALUES FROM (%L) TO (%L)', 
                   table_name, start_date, end_date);
END;
$$ LANGUAGE plpgsql;

-- 定期清理过期数据
CREATE OR REPLACE FUNCTION cleanup_old_behavior_logs()
RETURNS void AS $$
BEGIN
    DELETE FROM user_behavior_logs 
    WHERE created_at < CURRENT_DATE - interval '1 year';
END;
$$ LANGUAGE plpgsql;
```

---

## 📊 五、监控和维护

### 5.1 性能监控

```typescript
// monitoring/performance-monitor.ts
export class PerformanceMonitor {
  async checkDatabaseHealth() {
    const results = await prisma.$queryRaw`
      SELECT 
        schemaname,
        tablename,
        attname,
        n_distinct,
        correlation
      FROM pg_stats 
      WHERE schemaname = 'public'
        AND n_distinct > 100
      ORDER BY n_distinct DESC
      LIMIT 20
    `;
    
    return results;
  }

  async getSlowQueries() {
    const results = await prisma.$queryRaw`
      SELECT 
        query,
        calls,
        total_time,
        mean_time,
        rows
      FROM pg_stat_statements 
      WHERE mean_time > 100  -- 超过100ms的查询
      ORDER BY mean_time DESC
      LIMIT 10
    `;
    
    return results;
  }

  async checkIndexUsage() {
    const results = await prisma.$queryRaw`
      SELECT 
        schemaname,
        tablename,
        indexname,
        idx_scan,
        idx_tup_read,
        idx_tup_fetch
      FROM pg_stat_user_indexes
      WHERE idx_scan = 0  -- 未使用的索引
      ORDER BY tablename
    `;
    
    return results;
  }

  async monitorCacheHitRatio() {
    const results = await prisma.$queryRaw`
      SELECT 
        sum(heap_blks_read) as heap_read,
        sum(heap_blks_hit) as heap_hit,
        sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) as ratio
      FROM pg_statio_user_tables
    `;
    
    return results[0];
  }
}
```

### 5.2 自动化维护

```typescript
// maintenance/database-maintenance.ts
export class DatabaseMaintenance {
  async vacuumAnalyze() {
    await prisma.$executeRaw`VACUUM ANALYZE`;
  }

  async reindexTables() {
    const tables = ['characters', 'messages', 'user_behavior_logs'];
    
    for (const table of tables) {
      await prisma.$executeRawUnsafe(`REINDEX TABLE ${table}`);
    }
  }

  async updateStatistics() {
    await prisma.$executeRaw`ANALYZE`;
  }

  async cleanupExpiredData() {
    // 清理过期的推荐缓存
    await prisma.recommendationCache.deleteMany({
      where: {
        expiresAt: {
          lt: new Date()
        }
      }
    });

    // 清理旧的行为日志
    await prisma.userBehaviorLog.deleteMany({
      where: {
        createdAt: {
          lt: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000) // 1年前
        }
      }
    });
  }
}
```

---

## 🎯 六、实施建议

### 6.1 优先级排序

1. **高优先级** (立即实施)
   - SQLite → PostgreSQL 迁移
   - 基础向量搜索功能
   - Redis缓存实现
   - 核心性能优化

2. **中优先级** (1-2周内)
   - 角色市场功能
   - 基础社区功能
   - 用户行为分析
   - 推荐系统V1

3. **低优先级** (1-2月内)
   - 多模态AI功能
   - 高级分析功能
   - A/B测试系统
   - 完整的数据仓库

### 6.2 风险控制

```typescript
// risk-management/migration-safety.ts
export class MigrationSafety {
  async createCheckpoint(name: string) {
    // 创建数据库检查点
    await prisma.$executeRaw`CHECKPOINT ${name}`;
  }

  async validateDataConsistency() {
    // 数据一致性检查
    const inconsistencies = [];
    
    // 检查外键约束
    const orphanedRecords = await prisma.$queryRaw`
      SELECT 'characters' as table_name, COUNT(*) as count
      FROM characters c
      LEFT JOIN users u ON c.creator_id = u.id
      WHERE u.id IS NULL
      
      UNION ALL
      
      SELECT 'messages', COUNT(*)
      FROM messages m
      LEFT JOIN chat_sessions cs ON m.session_id = cs.id
      WHERE cs.id IS NULL
    `;
    
    return orphanedRecords;
  }

  async setupMonitoring() {
    // 设置监控告警
    // 集成到现有的监控系统
  }
}
```

### 6.3 成本估算

```typescript
// cost-analysis/infrastructure-cost.ts
export const INFRASTRUCTURE_COSTS = {
  postgresql: {
    development: "$50/月",  // 小型实例
    production: "$200/月"   // 高可用集群
  },
  redis: {
    development: "$30/月",  // 单实例
    production: "$150/月"   // 集群模式
  },
  vectorDatabase: {
    development: "$100/月", // Pinecone/Weaviate
    production: "$500/月"   // 企业级
  },
  storage: {
    development: "$20/月",  // 基础存储
    production: "$100/月"   // 高性能存储
  },
  monitoring: {
    development: "$0",      // 开源方案
    production: "$50/月"    // 专业监控
  },
  total: {
    development: "$200/月",
    production: "$1000/月"
  }
};
```

---

## 📋 七、总结

这个数据库架构扩展方案为TavernAI Plus提供了支持所有高级功能的完整基础设施。主要特点：

### ✅ 核心优势
1. **可扩展性**: 支持从当前50用户扩展到50万用户
2. **高性能**: 向量搜索、Redis缓存、分区表优化
3. **功能完整**: 涵盖角色市场、社区、推荐、多模态AI等
4. **生产就绪**: 完整的监控、备份、回滚机制

### 🎯 实施路径
1. **第一阶段**: PostgreSQL迁移 + 基础优化
2. **第二阶段**: 向量搜索 + 推荐系统
3. **第三阶段**: 社区功能 + 角色市场  
4. **第四阶段**: 多模态AI + 高级分析

### 📈 预期效果
- **查询性能**: 提升10-50倍
- **功能丰富度**: 增加300%+核心功能
- **用户体验**: 个性化推荐准确率>85%
- **系统稳定性**: 99.9%可用性保障

这个方案遵循了项目的核心原则，使用真实数据，提供生产级质量，为TavernAI Plus的长期发展奠定坚实基础。